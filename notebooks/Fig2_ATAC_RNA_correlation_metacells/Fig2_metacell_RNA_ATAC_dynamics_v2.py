# ---
# jupyter:
#   jupytext:
#     formats: ipynb,py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.16.5
#   kernelspec:
#     display_name: seacells
#     language: python
#     name: seacells
# ---

# %% [markdown] jp-MarkdownHeadingCollapsed=true
# ## Figure 2: gene UMAP (genes-by-celltypes&timepoint)
#
# - last updated: 9/5/2025
# - Author: Yang-Joon Kim
#
# - (1) aggregating the count matrices using Metacells (SEACells) - for both RNA and ATAC (gene.activity)
# - (2) computing the "gene-level" dynamics of RNA and ATAC (gene.activity) across celltype & timepoint (by averaging again across metacells)
# - (3) ALL gene UMAP
# - (4) classify the genes based on their temporal dynamics
#
#
#

# %% [markdown]
# # Imports

# %%
import numpy as np
import pandas as pd
import scanpy as sc
from scipy.stats import pearsonr

import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns
import os

# %%
# Some plotting aesthetics
# %matplotlib inline

sns.set_style('ticks')
matplotlib.rcParams['figure.figsize'] = [4, 4]
matplotlib.rcParams['figure.dpi'] = 300

# %%
import logging

# Set the logging level to WARN, filtering out informational messages
logging.getLogger().setLevel(logging.WARNING)

import matplotlib as mpl
mpl.rcParams.update(mpl.rcParamsDefault) #Reset rcParams to default

# Set the default font to Arial
mpl.rcParams['font.family'] = 'Arial'

# If Arial is not available on your system, you might need to specify an alternative or ensure Arial is installed.
# On some systems, you might need to use 'font.sans-serif' as a fallback option:
# mpl.rcParams['font.sans-serif'] = 'Arial'

# Editable text and proper LaTeX fonts in illustrator
# matplotlib.rcParams['ps.useafm'] = True
# Editable fonts. 42 is the magic number for editable text in PDFs
mpl.rcParams['pdf.fonttype'] = 42
sns.set(style='whitegrid', context='paper')

# %%
# Import from fig2_utils modules (refactored utilities)
import sys
# add the path to the fig2_utils modules
sys.path.append("/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/zebrahub-multiome-analysis/scripts/fig2_utils/")

# import the functions from the fig2_utils modules
from plotting_utils import set_plotting_style
from metacell_utils import compute_prevalent_celltype_per_metacell
from data_concatenation import (
    find_shared_genes,
    concatenate_data
)   
from temporal_analysis import (
    parse_var_names,
    split_by_modality,
    average_over_celltypes,
    median_over_celltypes,
    compute_peaks_and_range,
    normalize_for_alpha,
    normalize_for_alpha_robust,
    compute_peak_metrics
)

# %% [markdown]
# **Note:** Analysis functions refactored into `scripts/fig2_utils/` modules

# %% [markdown]
# ## NOTES
#
# The correlation between RNA and ATAC (gene.activity) was computed by the following steps:
#
# - 1) import integrated RNA/ATAC objects, respectively (ATAC has gene.activity)
# - 2) subset for each timepoint, import the SEACell information (metacells), then aggregate the counts (RNA/gene.activity)
# - 3) compute the pearson correlation coefficients between RNA and gene.activity for each gene, then save as dataframes

# %% [markdown]
# ## Step 1. Load the datasets

# %%
figpath = "/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/zebrahub-multiome-analysis/figures/RNA_ATAC_seacells_dynamics_v2/"
os.makedirs(figpath, exist_ok=True)

# %%
# Load the RNA and ATAC(gene.activity) master object, then subset for each timepoint/dataset
filepath = '/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/data/processed_data/01_Signac_processed/'

# RNA master object (all timepoints/datasets)
adata_RNA = sc.read_h5ad(filepath + "integrated_RNA_ATAC_counts_RNA_master_filtered.h5ad")
print(adata_RNA)

# ATAC (gene.acitivitiy) master object (all timepoints/datasets)
adata_ATAC = sc.read_h5ad(filepath + "integrated_RNA_ATAC_counts_gene_activity_raw_counts_master_filtered.h5ad")
print(adata_ATAC)

# %%
# computing the highly variable genes
sc.pp.highly_variable_genes(adata_RNA, layer="counts", flavor="seurat_v3", n_top_genes=3000)
adata_RNA

# %%
list_hvgs_rna = adata_RNA[:,adata_RNA.var.highly_variable].var_names.to_list()
print("meox1" in list_hvgs_rna)
print("cdx1a" in list_hvgs_rna)
print("slc4a1a" in list_hvgs_rna)

# %% [markdown]
# ### NOTE. anndata objects with aggregated counts for RNA and ATAC were generated by compute_seacells_atac.py script for each dataset

# %% [markdown]
# ### generate a UMAP highlighting SEACells along with single-cells colored by the celltypes
#
# - TDR126 (10hpf)

# %%
adata = sc.read_h5ad("/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/data/processed_data/05_SEACells_processed/TDR126_seacells_annotation_ML_coarse.h5ad")
adata

# %%
# reset the colors
# a color palette for the "coarse" grained celltype annotation ("annotation_ML_coarse")
cell_type_color_dict = {
    'NMPs': '#8dd3c7',
    'PSM': '#008080',
    'differentiating_neurons': '#bebada',
    'endocrine_pancreas': '#fb8072',
    'endoderm': '#80b1d3',
    'enteric_neurons': '#fdb462',
    'epidermis': '#b3de69',
    'fast_muscle': '#df4b9b',
    'floor_plate': '#d9d9d9',
    'hatching_gland': '#bc80bd',
    'heart_myocardium': '#ccebc5',
    'hemangioblasts': '#ffed6f',
    'hematopoietic_vasculature': '#e41a1c',
    'hindbrain': '#377eb8',
    'lateral_plate_mesoderm': '#4daf4a',
    'midbrain_hindbrain_boundary': '#984ea3',
    'muscle': '#ff7f00',
    'neural': '#e6ab02',
    'neural_crest': '#a65628',
    'neural_floor_plate': '#66a61e',
    'neural_optic': '#999999',
    'neural_posterior': '#393b7f',
    'neural_telencephalon': '#fdcdac',
    'neurons': '#cbd5e8',
    'notochord': '#f4cae4',
    'optic_cup': '#c0c000',
    'pharyngeal_arches': '#fff2ae',
    'primordial_germ_cells': '#f1e2cc',
    'pronephros': '#cccccc',
    'somites': '#1b9e77',
    'spinal_cord': '#d95f02',
    'tail_bud': '#7570b3'
}

# %%
sc.pl.embedding(adata, basis="X_umap.joint", color="annotation_ML_coarse", palette=cell_type_color_dict)


# %% [markdown]
# ### plot the metacells on top of the single-cells

# %% [markdown]
# ## Step 2. generate a genes-by-metacells matrix (concatenated over all time points)
#
# - We will perform a gene-centric analysis, where we create a genes-by-metacells count matrix, then concatenate all time points. This count matrice will have metadata for columns for (1) time point, and (2) cell type, etc.
# - Then, we can use this count matrix to average/aggregate over specific metadata, and look at the trends (PCA,UMAP)

# %%
metacell_path = "/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/data/processed_data/05_SEACells_processed/" 
data_id = "TDR126"
rna_meta_ad = sc.read_h5ad(metacell_path + f"{data_id}/{data_id}_RNA_seacells_aggre.h5ad")
atac_meta_ad = sc.read_h5ad(metacell_path + f"{data_id}/{data_id}_ATAC_seacells_aggre.h5ad")


# %%


# %%
if __name__ == "__main__":
    # define the list of datasets (data_id) and timepoints (hpf)

    list_datasets = ['TDR126', 'TDR127', 'TDR128',
                    'TDR118reseq', 'TDR125reseq', 'TDR124reseq']
    
    list_timepoints = ["10hpf","12hpf","14hpf","16hpf","19hpf","24hpf"]
    
    # Define the path to metacell data
    metacell_path = "/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/data/processed_data/05_SEACells_processed/objects_75cells_per_metacell/"
    
    # First, find shared genes
    shared_genes = find_shared_genes(list_datasets, metacell_path)
    
    # Then concatenate the data using these shared genes
    combined_rna, combined_atac = concatenate_data(list_datasets, list_timepoints, metacell_path, shared_genes)
    
    # Save the combined data
    # combined_rna.write_h5ad(metacell_path + "metacells_by_genes_RNA_concat.h5ad")
    # combined_atac.write_h5ad(metacell_path + "metacells_by_genes_ATAC_concat.h5ad")

# %% [markdown]
# ## [RESUME FROM HERE] Load the metacells-by-genes matrices for RNA and ATAC, respectively.

# %%
# Load the metacells-by-genes for RNA, and ATAC, respetively
combined_rna = sc.read_h5ad("/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/data/processed_data/05_SEACells_processed/objects_75cells_per_metacell/metacells_by_genes_RNA_concat.h5ad")
combined_atac = sc.read_h5ad("/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/data/processed_data/05_SEACells_processed/objects_75cells_per_metacell/metacells_by_genes_ATAC_concat.h5ad")

# %%
combined_rna

# %%
combined_rna.obs.head()

# %%
import scipy

# %%
# define the example gene and celltype
gene_name = "cdx1a"
subset = genes_by_meta_groups[genes_by_meta_groups.obs_names==gene_name]
subset

celltype = "NMPs"
# modality = "rna"

# Extract relevant columns (those matching cell type and modality)
pattern = f"{celltype}_.*_{modality}"
# matching_cols = [col for col in adata.var_names if re.match(pattern, col)]
# Extract RNA and ATAC data
rna_cols = [col for col in subset.var_names if f'{celltype}' in col and 'rna' in col]
atac_cols = [col for col in subset.var_names if f'{celltype}' in col and 'atac' in col]

# Create data for plotting
temporal_data = []
for col in rna_cols + atac_cols:
    # Extract timepoint (format: hemangioblasts_10hpf_rna)
    timepoint = int(col.split('_')[1].replace('hpf', ''))
    value = subset.X[0, subset.var_names.get_loc(col)]
    modality = 'RNA' if 'rna' in col else 'ATAC'
    temporal_data.append({
        'timepoint': timepoint,
        'value': value,
        'modality': modality
    })

# Convert to DataFrame and sort
df = pd.DataFrame(temporal_data)
df = df.sort_values(['modality', 'timepoint'])

# Create plot
plt.figure(figsize=(12, 6))
sns.lineplot(data=df, x='timepoint', y='value', hue='modality', marker='o', markersize=10)

# Customize plot
plt.xlabel('Time (hpf)')
plt.ylabel('Expression level')
plt.title(f'{gene_name} in {celltype}')
plt.grid(True, linestyle='--', alpha=0.7)
plt.xticks(df['timepoint'].unique())

# Add value labels
# for _, row in df.iterrows():
#     plt.annotate(f'{row["value"]:.2f}', 
#                 (row['timepoint'], row['value']),
#                 textcoords="offset points",
#                 xytext=(0,10),
#                 ha='center')

plt.tight_layout()
plt.grid(False)
plt.show()


# %% [markdown]
# # Take 2: revisit the gene filtering steps
# # 11/1/2024
#
# - (1) filter out the lowly expressed genes (noise) using RNA expression (scanpy's hvg) -> keeping top 10-15K genes
# - (2) filter for the genes with large variance over time and celltypes (top 2-3K for either RNA or ATAC, and compute the Joint)

# %% [markdown]
# ### Step 2-1. compute the highly variable genes (this way, we filter out the lowly expressed genes)

# %%
sc.settings.figdir = figpath

# %%
# computing the highly variable genes
sc.pp.highly_variable_genes(adata_RNA, layer="counts", flavor="seurat_v3", n_top_genes=10000)
adata_RNA

# %%
adata_RNA.var

# %%
adata_RNA.var.sort_values("variances_norm", ascending=True).index[0:50]

# %%
list_genes_check = ["meox1","msgn1","myf5","pax6a","pax6b","ved","vox","sox19a","hmga1a",
                    "sox2","tbxta","sox3","foxp4","sox11a","sox13","rfx4","meis1b"]

# %%
list_hvgs_rna = adata_RNA[:,adata_RNA.var.highly_variable].var_names.to_list()

# for gene in list_genes_check:
#     print(gene in list_hvgs_rna)

# %%
# compute the average for "celltype", and "timepoint"
rna_meta_grouped = compute_group_averages(combined_rna, group_by=["celltype","timepoint"])
rna_meta_grouped

atac_meta_grouped = compute_group_averages(combined_atac, group_by=["celltype","timepoint"])
atac_meta_grouped

# %%
# save the "averaged" log-normalized counts into the layer
rna_meta_grouped.layers["raw"] = rna_meta_grouped.X.copy()
atac_meta_grouped.layers["raw"] = atac_meta_grouped.X.copy()

# %%
rna_meta_grouped.obs_names = rna_meta_grouped.obs_names + "_rna"
rna_meta_grouped.obs_names

# %%
atac_meta_grouped.obs_names = atac_meta_grouped.obs_names + "_atac"
atac_meta_grouped.obs_names

# %%
# filter for the 10K highly variagle genes from RNA gene expression (across single-cells)
rna_meta_grouped_filt = rna_meta_grouped[:,rna_meta_grouped.var_names.isin(list_hvgs_rna)]
atac_meta_grouped_filt = atac_meta_grouped[:,atac_meta_grouped.var_names.isin(list_hvgs_rna)]

# %%
rna_meta_grouped_filt

# %% [markdown]
# ## Step 2-2. compute the mean/variance for each gene across time, metacell concatenated vectors
#

# %%
list_datasets

# %%
from collections import Counter
import scipy as sci

# Initialize a dictionary to store the cell type counts for each gene
celltype_counts = {}

# Loop through each data_id (representing each timepoint)
for i, data_id in enumerate(list_datasets):
    # Import the RNA and ATAC adata objects (aggregated over metacells)
    data_name = data_id.strip("reseq")
    rna_meta_ad = sc.read_h5ad(metacell_path + f"{data_id}/{data_name}_RNA_seacells_aggre.h5ad")
    atac_meta_ad = sc.read_h5ad(metacell_path + f"{data_id}/{data_name}_ATAC_seacells_aggre.h5ad")
    
    # Import the RNA adata (not aggregated) to compute prevalent cell types
    rna_ad = sc.read_h5ad(metacell_path + f"{data_id}/{data_name}_RNA_seacells.h5ad")
    
    # Compute the most prevalent cell type for each metacell
    prevalent_celltypes = compute_prevalent_celltype_per_metacell(rna_ad, celltype_key="annotation_ML_coarse", metacell_key="SEACell")
    
    # Subset the features that are shared between RNA and ATAC (gene names)
    shared_genes = np.intersect1d(rna_meta_ad.var_names, atac_meta_ad.var_names)
    print(f"Number of shared genes: {len(shared_genes)}")

    # Subset the RNA and ATAC objects for the shared genes
    rna_meta_ad = rna_meta_ad[:, shared_genes]
    atac_meta_ad = atac_meta_ad[:, shared_genes]
    
    # Map the prevalent cell types to each metacell in the obs
    rna_meta_ad.obs["celltype"] = rna_meta_ad.obs_names.map(prevalent_celltypes)
    atac_meta_ad.obs["celltype"] = atac_meta_ad.obs_names.map(prevalent_celltypes)
    
    # Compute the top 2 cell types based on combined RNA and ATAC values for each gene at the current timepoint
    top_two_celltypes = compute_top_two_celltypes_by_combined_expression(rna_meta_ad, atac_meta_ad)
    
    # For each gene, count the top 2 cell types across all timepoints
    for gene, celltypes in top_two_celltypes.items():
        if gene not in celltype_counts:
            celltype_counts[gene] = []
        # Append the top 2 cell types for this gene and this timepoint
        celltype_counts[gene].extend(celltypes)

# After processing all timepoints, find the top 2 most prevalent cell types across all timepoints for each gene
final_results = {}

for gene, celltypes in celltype_counts.items():
    # Count the frequency of each cell type
    celltype_counter = Counter(celltypes)
    # Get the top 2 most common cell types
    top_two_celltypes = celltype_counter.most_common(2)
    final_results[gene] = [ct[0] for ct in top_two_celltypes]

# Convert the final results to a DataFrame
final_df = pd.DataFrame.from_dict(final_results, orient='index', columns=['top_celltype_1', 'top_celltype_2'])

# Display the final results DataFrame
print(final_df)


# %%
# from sklearn.utils.extmath import median_absolute_deviation
import scipy.sparse as sp
from scipy.stats import median_abs_deviation

# %%
# compute the mean/variance for each gene across time, metacell concatenated vectors
# Compute stats for both RNA and ATAC
rna_stats = compute_gene_stats(rna_meta_grouped_filt)
atac_stats = compute_gene_stats(atac_meta_grouped_filt)

# %%
rna_stats

# %%
rna_stats.sort_values("robust_var_median_ratio", ascending=False)

# %%
# check the overlap between top genes for "robust_var_median_ratio" and "var_mean_ratio"
# Get the top 2000 genes for each metric
top_2000_robust_var_median_ratio = rna_stats.nlargest(2000, 'robust_var_median_ratio').index
top_2000_var_mean_ratio = rna_stats.nlargest(2000, 'var_mean_ratio').index

# Convert to sets for easy comparison
set_robust_var_median_ratio = set(top_2000_robust_var_median_ratio)
set_var_mean_ratio = set(top_2000_var_mean_ratio)

# Find common genes
common_genes = set_robust_var_median_ratio.intersection(set_var_mean_ratio)

# Find genes unique to each set
unique_to_robust = set_robust_var_median_ratio - set_var_mean_ratio
unique_to_var_mean = set_var_mean_ratio - set_robust_var_median_ratio

# Print results or save them to files if needed
print(f"Number of common genes: {len(common_genes)}")
print(f"Number of genes unique to robust_var_median_ratio: {len(unique_to_robust)}")
print(f"Number of genes unique to var_mean_ratio: {len(unique_to_var_mean)}")

# Optionally, convert to lists if you need them in list format
common_genes_list = list(common_genes)
unique_to_robust_list = list(unique_to_robust)
unique_to_var_mean_list = list(unique_to_var_mean)

# %%
# filter the object with the top genes (union of highly variable genes for either RNA or ATAC over time and celltypes)
rna_meta_grouped_filt = rna_meta_grouped_filt[:,rna_meta_grouped_filt.var_names.isin(top_genes_union)]
atac_meta_grouped_filt = atac_meta_grouped_filt[:,atac_meta_grouped_filt.var_names.isin(top_genes_union)]



# %% [markdown]
# ## repeating this gene filtering step systematically and see how the global structure changes

# %%
rna_stats

# %%
# Compute stats for both RNA and ATAC
# rna_stats = compute_gene_stats(rna_meta_grouped_filt)
# atac_stats = compute_gene_stats(atac_meta_grouped_filt)
from scipy import stats

list_n_tops = [5000, 4000, 3000, 2500, 2000, 1500, 1000, 500, 300, 100]

for n_top in list_n_tops:
    # Get top genes for each metric
    # n_top = 2000  # or 2000, as you prefer

    # RNA top genes
    # rna_top_var = set(rna_stats.nlargest(n_top, 'variance').index)
    # rna_top_mean = set(rna_stats.nlargest(n_top, 'mean').index)
    rna_top_ratio = set(rna_stats.nlargest(n_top, 'var_mean_ratio').index)

    # ATAC top genes
    # atac_top_var = set(atac_stats.nlargest(n_top, 'variance').index)
    # atac_top_mean = set(atac_stats.nlargest(n_top, 'mean').index)
    atac_top_ratio = set(atac_stats.nlargest(n_top, 'var_mean_ratio').index)

    # Get union of top genes
    top_genes_union = set.union(rna_top_ratio, atac_top_ratio)

    print(f"Number of genes in union: {len(top_genes_union)}")
    
    # filter the object with the top genes (union of highly variable genes for either RNA or ATAC over time and celltypes)
    rna_meta_grouped_hvg = rna_meta_grouped_filt[:,rna_meta_grouped_filt.var_names.isin(top_genes_union)]
    atac_meta_grouped_hvg = atac_meta_grouped_filt[:,atac_meta_grouped_filt.var_names.isin(top_genes_union)]
    
    # Compute standard deviations
    std_rna = rna_meta_grouped_hvg.X.std(axis=0)
    std_atac = atac_meta_grouped_hvg.X.std(axis=0)

    # Find indices of non-constant genes (std > 0)
    non_constant_rna = std_rna > 0
    non_constant_atac = std_atac > 0
    
    # Compute the joint non-constant indices
    non_constant_joint = non_constant_rna & non_constant_atac

    # Filter the AnnData objects
    rna_filtered = rna_meta_grouped_hvg[:, non_constant_joint]
    atac_filtered = atac_meta_grouped_hvg[:, non_constant_joint]
    
    # total number of genes
    n_genes_total = len(rna_filtered.X[1,:])
    
    # Simple z-score across all conditions (celltypes, timepoints) for each gene
    rna_meta_zscore = rna_filtered.copy()
    rna_meta_zscore.X = stats.zscore(rna_meta_zscore.X, axis=0)

    atac_meta_zscore = atac_filtered.copy()
    atac_meta_zscore.X = stats.zscore(atac_meta_zscore.X, axis=0)
    
    # Count total number of NaN values
    n_nans = np.isnan(rna_meta_zscore.X).sum()
    print(f"Total NaN values: {n_nans}")
    n_nans = np.isnan(atac_meta_zscore.X).sum()
    print(f"Total NaN values: {n_nans}")
    
    # transpose the matrices to be genes-by-(celltype, timepoint)
    rna_meta_trans = rna_meta_zscore.copy().T
    atac_meta_trans = atac_meta_zscore.copy().T
    
    # concatenate the RNA and ATAC (genes-by-(timepoint, celltype, modality)
    genes_by_meta_groups = sc.concat([rna_meta_trans, atac_meta_trans], axis=1, join="outer")
    genes_by_meta_groups
    
    # computing the dim.reduction
    sc.tl.pca(genes_by_meta_groups, svd_solver="arpack")
    # sc.pl.pca(genes_by_meta_groups)

    # Compute UMAP
    sc.pp.neighbors(genes_by_meta_groups, n_neighbors=10, n_pcs=40)
    sc.tl.umap(genes_by_meta_groups, min_dist=0.1, random_state=42,)
    # sc.pl.umap(genes_by_meta_groups)
    
    # transfer the marker celltype label
    # final_df[final_df.index.isin(top_genes_union)]    
    genes_by_meta_groups.obs["celltype1"] = genes_by_meta_groups.obs_names.map(final_df["top_celltype_1"])
    genes_by_meta_groups.obs["celltype2"] = genes_by_meta_groups.obs_names.map(final_df["top_celltype_2"])
    
    # plot the UMAP and save
    sc.pl.umap(genes_by_meta_groups, 
           color=["celltype1", "celltype2"],
           palette=cell_type_color_dict,
           legend_loc='bottom',
           legend_fontoutline=2,
           legend_fontsize=8,
           ncols=6,  # Adjust this to control how many columns in the legend
           wspace=0.4,  # Adjust spacing between plots
           size=30,
           frameon=False, save=f"_genes_hvg_var_mean_num_genes_{str(n_genes_total)}.png")

# %% [markdown]
# ### robust_variance/median

# %%
# Compute stats for both RNA and ATAC
# rna_stats = compute_gene_stats(rna_meta_grouped_filt)
# atac_stats = compute_gene_stats(atac_meta_grouped_filt)
from scipy import stats

list_n_tops = [5000, 4000, 3000, 2500, 2000, 1500, 1000, 500, 300, 100]

for n_top in list_n_tops:
    # Get top genes for each metric
    # n_top = 2000  # or 2000, as you prefer

    # RNA top genes
    # rna_top_var = set(rna_stats.nlargest(n_top, 'variance').index)
    # rna_top_mean = set(rna_stats.nlargest(n_top, 'mean').index)
    rna_top_ratio = set(rna_stats.nlargest(n_top, 'robust_var_median_ratio').index)

    # ATAC top genes
    # atac_top_var = set(atac_stats.nlargest(n_top, 'variance').index)
    # atac_top_mean = set(atac_stats.nlargest(n_top, 'mean').index)
    atac_top_ratio = set(atac_stats.nlargest(n_top, 'robust_var_median_ratio').index)

    # Get union of top genes
    top_genes_union = set.union(rna_top_ratio, atac_top_ratio)

    print(f"Number of genes in union: {len(top_genes_union)}")
    
    # filter the object with the top genes (union of highly variable genes for either RNA or ATAC over time and celltypes)
    rna_meta_grouped_hvg = rna_meta_grouped_filt[:,rna_meta_grouped_filt.var_names.isin(top_genes_union)]
    atac_meta_grouped_hvg = atac_meta_grouped_filt[:,atac_meta_grouped_filt.var_names.isin(top_genes_union)]
    
    # Compute standard deviations
    std_rna = rna_meta_grouped_hvg.X.std(axis=0)
    std_atac = atac_meta_grouped_hvg.X.std(axis=0)

    # Find indices of non-constant genes (std > 0)
    non_constant_rna = std_rna > 0
    non_constant_atac = std_atac > 0
    
    # Compute the joint non-constant indices
    non_constant_joint = non_constant_rna & non_constant_atac

    # Filter the AnnData objects
    rna_filtered = rna_meta_grouped_hvg[:, non_constant_joint]
    atac_filtered = atac_meta_grouped_hvg[:, non_constant_joint]
    
    # total number of genes
    n_genes_total = len(rna_filtered.X[1,:])
    
    # Simple z-score across all conditions (celltypes, timepoints) for each gene
    rna_meta_zscore = rna_filtered.copy()
    rna_meta_zscore.X = stats.zscore(rna_meta_zscore.X, axis=0)

    atac_meta_zscore = atac_filtered.copy()
    atac_meta_zscore.X = stats.zscore(atac_meta_zscore.X, axis=0)
    
    # Count total number of NaN values
    n_nans = np.isnan(rna_meta_zscore.X).sum()
    print(f"Total NaN values: {n_nans}")
    n_nans = np.isnan(atac_meta_zscore.X).sum()
    print(f"Total NaN values: {n_nans}")
    
    # transpose the matrices to be genes-by-(celltype, timepoint)
    rna_meta_trans = rna_meta_zscore.copy().T
    atac_meta_trans = atac_meta_zscore.copy().T
    
    # concatenate the RNA and ATAC (genes-by-(timepoint, celltype, modality)
    genes_by_meta_groups = sc.concat([rna_meta_trans, atac_meta_trans], axis=1, join="outer")
    genes_by_meta_groups
    
    # computing the dim.reduction
    sc.tl.pca(genes_by_meta_groups, svd_solver="arpack")
    # sc.pl.pca(genes_by_meta_groups)

    # Compute UMAP
    sc.pp.neighbors(genes_by_meta_groups, n_neighbors=10, n_pcs=40)
    sc.tl.umap(genes_by_meta_groups, min_dist=0.1, random_state=42,)
    # sc.pl.umap(genes_by_meta_groups)
    
    # transfer the marker celltype label
    # final_df[final_df.index.isin(top_genes_union)]    
    genes_by_meta_groups.obs["celltype1"] = genes_by_meta_groups.obs_names.map(final_df["top_celltype_1"])
    genes_by_meta_groups.obs["celltype2"] = genes_by_meta_groups.obs_names.map(final_df["top_celltype_2"])
    
    # plot the UMAP and save
    sc.pl.umap(genes_by_meta_groups, 
           color=["celltype1", "celltype2"],
           palette=cell_type_color_dict,
           legend_loc='bottom',
           legend_fontoutline=2,
           legend_fontsize=8,
           ncols=6,  # Adjust this to control how many columns in the legend
           wspace=0.4,  # Adjust spacing between plots
           size=30,
           frameon=False, save=f"_genes_hvg_robust_var_median_num_genes_{str(n_genes_total)}.png")

# %% [markdown]
# ### deeper dive into specific example

# %%
rna_meta_grouped_filt

# %%
# Get top genes for each metric
n_top = 4000

# RNA top genes
rna_top_ratio = set(rna_stats.nlargest(n_top, 'var_mean_ratio').index)
# ATAC top genes
atac_top_ratio = set(atac_stats.nlargest(n_top, 'var_mean_ratio').index)
# Get union of top genes
top_genes_union = set.union(rna_top_ratio, atac_top_ratio)
print(f"Number of genes in union: {len(top_genes_union)}")

# filter the object with the top genes (union of highly variable genes for either RNA or ATAC over time and celltypes)
rna_meta_grouped_hvg = rna_meta_grouped_filt[:,rna_meta_grouped_filt.var_names.isin(top_genes_union)]
atac_meta_grouped_hvg = atac_meta_grouped_filt[:,atac_meta_grouped_filt.var_names.isin(top_genes_union)]

# Compute standard deviations
std_rna = rna_meta_grouped_hvg.X.std(axis=0)
std_atac = atac_meta_grouped_hvg.X.std(axis=0)

# Find indices of non-constant genes (std > 0)
non_constant_rna = std_rna > 0
non_constant_atac = std_atac > 0

# Compute the joint non-constant indices
non_constant_joint = non_constant_rna & non_constant_atac

# Filter the AnnData objects
rna_filtered = rna_meta_grouped_hvg[:, non_constant_joint]
atac_filtered = atac_meta_grouped_hvg[:, non_constant_joint]

# total number of genes
n_genes_total = len(rna_filtered.X[1,:])

# Simple z-score across all conditions (celltypes, timepoints) for each gene
rna_meta_zscore = rna_filtered.copy()
rna_meta_zscore.X = stats.zscore(rna_meta_zscore.X, axis=0)

atac_meta_zscore = atac_filtered.copy()
atac_meta_zscore.X = stats.zscore(atac_meta_zscore.X, axis=0)

# Count total number of NaN values
n_nans = np.isnan(rna_meta_zscore.X).sum()
print(f"Total NaN values: {n_nans}")
n_nans = np.isnan(atac_meta_zscore.X).sum()
print(f"Total NaN values: {n_nans}")

# transpose the matrices to be genes-by-(celltype, timepoint)
rna_meta_trans = rna_meta_zscore.copy().T
atac_meta_trans = atac_meta_zscore.copy().T

# concatenate the RNA and ATAC (genes-by-(timepoint, celltype, modality)
genes_by_meta_groups = sc.concat([rna_meta_trans, atac_meta_trans], axis=1, join="outer")
genes_by_meta_groups

# computing the dim.reduction
sc.tl.pca(genes_by_meta_groups, svd_solver="arpack")
# sc.pl.pca(genes_by_meta_groups)

# Compute UMAP
sc.pp.neighbors(genes_by_meta_groups, n_neighbors=10, n_pcs=40)
sc.tl.umap(genes_by_meta_groups, min_dist=0.1, random_state=42)
# sc.pl.umap(genes_by_meta_groups)

# transfer the marker celltype label
# final_df[final_df.index.isin(top_genes_union)]    
genes_by_meta_groups.obs["celltype1"] = genes_by_meta_groups.obs_names.map(final_df["top_celltype_1"])
genes_by_meta_groups.obs["celltype2"] = genes_by_meta_groups.obs_names.map(final_df["top_celltype_2"])

# plot the UMAP and save
sc.pl.umap(genes_by_meta_groups, 
       color=["celltype1", "celltype2"],
       palette=cell_type_color_dict,
       legend_loc='bottom',
       legend_fontoutline=2,
       legend_fontsize=8,
       ncols=6,  # Adjust this to control how many columns in the legend
       wspace=0.4,  # Adjust spacing between plots
       frameon=False, save=f"_genes_hvg_num_genes_{str(n_genes_total)}.png")

# genes_by_meta_groups.write_h5ad("/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/data/processed_data/annotations/genes_by_ct_tp_top_5081genes.h5ad")

# %%
# plot the UMAP and save
sc.pl.umap(genes_by_meta_groups, 
       color=["celltype1","celltype2"],
       palette=cell_type_color_dict,
       legend_loc='bottom',
       legend_fontoutline=2,
       legend_fontsize=8,
       ncols=6,  # Adjust this to control how many columns in the legend
       wspace=0.4,  # Adjust spacing between plots
       frameon=False, save=f"_genes_hvg_num_genes_{str(n_genes_total)}.png")

# %% [markdown]
# ### Using Cellxgene to annotate the clusters far out, and also performed leiden clustering

# %%
annotation = pd.read_csv("/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/zebrahub-multiome-analysis/notebooks/Fig2_ATAC_RNA_correlation_metacells/gene_clustering_result/gene_umap_5077.txt", sep="\t", index_col=0)
annotation

# %%
annotation[annotation.manual_annotation=="left_bottom"]

# %%
annotation[annotation.manual_annotation=="right_bottom"]

# %%
# get the list of genes to exclude
genes_to_exclude = annotation[
    (annotation['manual_annotation'] == "left_bottom") | 
    (annotation['manual_annotation'] == "right_bottom")
].index

genes_to_exclude

# %%
# filter out the small clusters that are irrelevant
genes_by_meta_groups_filt = genes_by_meta_groups[~genes_by_meta_groups.obs_names.isin(genes_to_exclude)]
genes_by_meta_groups_filt

# %%
# save this adata (genes-by-celltype&timepoint, z-scored in adata.X, and saving the "raw" layers for the log-normalized counts)
genes_by_meta_groups_filt.write_h5ad("/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/data/processed_data/annotations/genes_by_ct_tp_top_5068genes.h5ad")

# %%
# plot the UMAP and save
sc.pl.umap(genes_by_meta_groups_filt, 
       color=["celltype1","celltype2"],
       palette=cell_type_color_dict,
       legend_loc='bottom',
       legend_fontoutline=2,
       legend_fontsize=8,
       ncols=6,  # Adjust this to control how many columns in the legend
       wspace=0.4,  # Adjust spacing between plots
       frameon=False, save="_genes_hvg_num_genes_5068.png")

# %%
# plot the UMAP and save
sc.pl.umap(genes_by_meta_groups_filt, 
       color=["leiden_0.5","leiden_0.7"],
       # palette=cell_type_color_dict,
       legend_loc='bottom',
       legend_fontoutline=2,
       legend_fontsize=8,
       ncols=6,  # Adjust this to control how many columns in the legend
       wspace=0.4,  # Adjust spacing between plots
       frameon=False, save="_genes_hvg_num_genes_5068_leiden.png")

# %%
# transfer the annotations for leiden clustering
genes_by_meta_groups_filt.obs["leiden_0.5"] = genes_by_meta_groups_filt.obs_names.map(annotation["leiden_v1_r0.5"].astype("category"))
genes_by_meta_groups_filt.obs["leiden_0.7"] = genes_by_meta_groups_filt.obs_names.map(annotation["leiden_v2_r0.7"].astype("category"))

# %%
# plot the UMAP and save
sc.pl.umap(genes_by_meta_groups_filt, 
       color=["leiden_0.7"], save=f"_genes_hvg_num_genes_5068.pdf")

# %%
annotation[annotation.index=="cdx1a"]

# %%
annotation[annotation.index=="slc4a1a"]

# %%
genes_by_meta_groups_filt.obs

# %%
# save the z-scored (along the celltype&timepoint for each gene) counts in "z_score" layer
genes_by_meta_groups_filt.layers["z_score"] = genes_by_meta_groups_filt.X.copy()

# %% [markdown]
# ### check each leiden cluster (leiden_0.7) to identify the patterns
#
# - We will check each leiden cluster, and first monitor which celltypes are dominant
# - For interesting clusters, we will also perform gene set enrichment analysis to see which clusters are enriched with specific pathways (ultimately to link celltypes)

# %%
figpath

# %%
# loop through the leiden clusters and compute the most prevalent celltypes (first and the second), and their "purity"

# Create a dictionary to store results
cluster_analysis = {}

# Loop through each leiden cluster
for cluster in genes_by_meta_groups_filt.obs["leiden_0.7"].unique():
    # Get celltype counts for this cluster
    celltype_counts = genes_by_meta_groups_filt[genes_by_meta_groups_filt.obs["leiden_0.7"]==cluster].obs["celltype1"].value_counts()
    
    # Get total cells in cluster
    total_cells = celltype_counts.sum()
    
    # Get top 2 celltypes
    top1_celltype = celltype_counts.index[0]
    top1_count = celltype_counts.iloc[0]
    top2_celltype = celltype_counts.index[1]
    top2_count = celltype_counts.iloc[1]
    
    # Calculate purities
    top1_purity = top1_count / total_cells
    top2_purity = top2_count / total_cells
    combined_purity = (top1_count + top2_count) / total_cells
    
    # Store results
    cluster_analysis[cluster] = {
        'total_cells': total_cells,
        'top1_celltype': top1_celltype,
        'top1_count': top1_count,
        'top1_purity': top1_purity,
        'top2_celltype': top2_celltype,
        'top2_count': top2_count,
        'top2_purity': top2_purity,
        'combined_purity': combined_purity
    }

# Convert to DataFrame for easier viewing
results_df = pd.DataFrame.from_dict(cluster_analysis, orient='index')

# Sort by cluster number (assuming clusters are numbered)
results_df = results_df.sort_index()

# Display results
print("Cluster Analysis Results:")
print(results_df)

# Optional: Create visualizations
import matplotlib.pyplot as plt
import seaborn as sns

# Plot top1 purities
plt.figure(figsize=(10, 5))
sns.barplot(data=results_df.reset_index(), x='index', y='top1_purity')
plt.title('Top Celltype Purity by Cluster')
plt.xlabel('Cluster')
plt.ylabel('Purity')
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig(figpath + "leiden_0.7_combined_purity_celltypes_top_celltype.pdf")
plt.show()

# Plot combined purities
plt.figure(figsize=(10, 5))
sns.barplot(data=results_df.reset_index(), x='index', y='combined_purity')
plt.title('Combined Top 2 Celltypes Purity by Cluster')
plt.xlabel('Cluster')
plt.ylabel('Combined Purity')
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig(figpath + "leiden_0.7_combined_purity_celltypes_top_two.pdf")
plt.show()

# %%
genes_by_meta_groups_filt[genes_by_meta_groups_filt.obs["leiden_0.7"]==5].obs.value_counts("celltype1")

# %%
# Create a directory to save the gene lists if it doesn't exist
# import os
output_dir = "/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/zebrahub-multiome-analysis/notebooks/Fig2_ATAC_RNA_correlation_metacells/gene_lists_by_cluster_leiden_0_7"  # specify your desired output directory
os.makedirs(output_dir, exist_ok=True)

# Loop through each leiden cluster
for cluster in genes_by_meta_groups_filt.obs["leiden_0.7"].unique():
    # Get genes for this cluster
    genes_in_cluster = genes_by_meta_groups_filt[genes_by_meta_groups_filt.obs["leiden_0.7"]==cluster].obs_names
    
    # Create filename
    filename = os.path.join(output_dir, f"cluster_{cluster}_genes.txt")
    
    # Save to file, one gene per line
    with open(filename, 'w') as f:
        for gene in genes_in_cluster:
            f.write(f"{gene}\n")
    
    print(f"Saved {len(genes_in_cluster)} genes for cluster {cluster}")

# # Optional: Create a summary file with cluster information
# with open(os.path.join(output_dir, "cluster_summary.txt"), 'w') as f:
#     f.write("Cluster\tNumber_of_genes\tTop1_celltype\tTop1_purity\tTop2_celltype\tTop2_purity\n")
#     for cluster in results_df.index:
#         f.write(f"{cluster}\t{len(genes_by_meta_groups_filt[genes_by_meta_groups_filt.obs['leiden_0.7']==cluster])}\t"
#                 f"{results_df.loc[cluster, 'top1_celltype']}\t{results_df.loc[cluster, 'top1_purity']:.3f}\t"
#                 f"{results_df.loc[cluster, 'top2_celltype']}\t{results_df.loc[cluster, 'top2_purity']:.3f}\n")

# %%

# %% [markdown]
# ### computing the timepoint where the gene expression/activity peak (and dynamic range)
#
# - 

# %%
genes_by_meta_groups_filt

# %%
genes_by_meta_groups_filt.var_names


# %%
# Function to parse var_names into components
def parse_var_names(var_name):
    parts = var_name.split('_')
    # Handle special cases where celltype might contain underscore
    if parts[-1] in ['rna', 'atac']:
        modality = parts[-1]
        timepoint = parts[-2]  # e.g., '10hpf'
        celltype = '_'.join(parts[:-2])  # Join back celltypes that might contain underscore
        return celltype, timepoint, modality
    return None, None, None


# %%
# Create dictionaries to store parsed information
parsed_info = [parse_var_names(var_name) for var_name in genes_by_meta_groups_filt.var_names]
df_info = pd.DataFrame(parsed_info, columns=['celltype', 'timepoint', 'modality'], index=genes_by_meta_groups_filt.var_names)

# conver the counts layer to "raw" (log-normalization, then averaged over metacells )

# Convert adata to dataframe for easier manipulation
expression_df = pd.DataFrame(genes_by_meta_groups_filt.X, 
                             columns=genes_by_meta_groups_filt.var_names,
                             index=genes_by_meta_groups_filt.obs_names)
expression_df

# %%
# First, let's correctly identify unique celltypes and timepoints
unique_celltypes = df_info['celltype'].unique()
unique_timepoints = df_info['timepoint'].unique()

# Function to split by modality
def split_by_modality(df, df_info, modality):
    cols = df_info[df_info['modality'] == modality].index
    return df[cols]

# Function to compute average across celltypes for each timepoint
def average_over_celltypes(df, df_info, modality):
    result_dict = {}
    
    for tp in sorted(unique_timepoints):
        # Get all columns for this timepoint and modality
        mask = (df_info['timepoint'] == tp) & (df_info['modality'] == modality)
        tp_cols = df_info[mask].index
        # Average across celltypes for this timepoint
        result_dict[tp] = df[tp_cols].mean(axis=1)
    
    return pd.DataFrame(result_dict, index=df.index)

# Compute averages
rna_df = split_by_modality(expression_df, df_info, 'rna')
atac_df = split_by_modality(expression_df, df_info, 'atac')

rna_celltype_avg = average_over_celltypes(rna_df, df_info, 'rna')
atac_celltype_avg = average_over_celltypes(atac_df, df_info, 'atac')

# Print summary
print(f"Number of unique celltypes: {len(unique_celltypes)}")
print(f"Number of timepoints: {len(unique_timepoints)}")
print("\nUnique celltypes:")
print(sorted(unique_celltypes))
print("\nTimepoints:")
print(sorted(unique_timepoints))

print("\nRNA averages shape (genes x timepoints):", rna_celltype_avg.shape)
print("ATAC averages shape (genes x timepoints):", atac_celltype_avg.shape)
print("\nFirst few rows of RNA averages:")
print(rna_celltype_avg.head())
print("\nFirst few rows of ATAC averages:")
print(atac_celltype_avg.head())


# %%
def analyze_distribution(df, df_info, modality):
    # Get stats for each gene's distribution across celltypes
    stats_dict = {}
    skew_dict = {}
    
    for tp in sorted(unique_timepoints):
        mask = (df_info['timepoint'] == tp) & (df_info['modality'] == modality)
        tp_cols = df_info[mask].index
        data = df[tp_cols]
        
        # Compute mean, median, and skewness for each gene
        stats_dict[tp] = pd.DataFrame({
            'mean': data.mean(axis=1),
            'median': data.median(axis=1),
            'skewness': data.apply(lambda x: stats.skew(x), axis=1)
        })
        
        # Count highly skewed distributions
        skew_dict[tp] = (abs(stats_dict[tp]['skewness']) > 1).sum()
    
    return pd.concat(stats_dict), pd.Series(skew_dict)

# Analyze distributions
rna_stats, rna_skew = analyze_distribution(rna_df, df_info, 'rna')
atac_stats, atac_skew = analyze_distribution(atac_df, df_info, 'atac')

print("Number of highly skewed genes at each timepoint (RNA):")
print(rna_skew)
print("\nNumber of highly skewed genes at each timepoint (ATAC):")
print(atac_skew)

# Plot comparison
plt.figure(figsize=(10, 5))
plt.scatter(rna_stats['mean'], rna_stats['median'], alpha=0.1)
plt.plot([rna_stats.min().min(), rna_stats.max().max()], 
         [rna_stats.min().min(), rna_stats.max().max()], 'r--')
plt.xlabel('Mean')
plt.ylabel('Median')
plt.title('Mean vs Median Comparison')
plt.show()


# %%
# Function to compute "median" across celltypes for each timepoint
def median_over_celltypes(df, df_info, modality):
    result_dict = {}
    
    for tp in sorted(unique_timepoints):
        # Get all columns for this timepoint and modality
        mask = (df_info['timepoint'] == tp) & (df_info['modality'] == modality)
        tp_cols = df_info[mask].index
        # Average across celltypes for this timepoint
        result_dict[tp] = np.median(df[tp_cols], axis=1)
    
    return pd.DataFrame(result_dict, index=df.index)

rna_celltype_median = median_over_celltypes(rna_df, df_info, 'rna')
atac_celltype_median = median_over_celltypes(atac_df, df_info, 'atac')


# %%
# Function to find peak timepoint and compute dynamic range
def compute_peaks_and_range(row):
    # Find peak timepoint
    peak_timepoint = row.idxmax()
    # Compute dynamic metrics
    std_dev = row.std()
    variance = row.var()
    dynamic_range = row.max() - row.min()  # max-min difference
    mean = row.mean()
    max_value = row.max()
    return pd.Series({
        'peak_timepoint': peak_timepoint,
        'std_dev': std_dev,
        'variance': variance,
        'dynamic_range': dynamic_range,
        'mean':mean,
        'max':max_value
    })

# Compute metrics for RNA
rna_dynamics = rna_celltype_avg.apply(compute_peaks_and_range, axis=1)
rna_dynamics = rna_dynamics.rename(columns={
    'peak_timepoint': 'peak_rna',
    'std_dev': 'std_dev_rna',
    'variance': 'variance_rna',
    'dynamic_range': 'dynamic_range_rna',
    'mean':'mean_rna',
    'max':'max_rna'
})

# Compute metrics for ATAC
atac_dynamics = atac_celltype_avg.apply(compute_peaks_and_range, axis=1)
atac_dynamics = atac_dynamics.rename(columns={
    'peak_timepoint': 'peak_atac',
    'std_dev': 'std_dev_atac',
    'variance': 'variance_atac',
    'dynamic_range': 'dynamic_range_atac',
    'mean':'mean_atac',
    'max':'max_atac'
})


# %%
# Combine the results
dynamics_summary = pd.concat([rna_dynamics, atac_dynamics], axis=1)

# Print first few rows
print("Dynamics summary for first few genes:")
print(dynamics_summary.head())

# Optional: Summary statistics
print("\nSummary of peak timepoints:")
print("RNA peaks:\n", dynamics_summary['peak_rna'].value_counts())
print("\nATAC peaks:\n", dynamics_summary['peak_atac'].value_counts())

# %%
# plt.scatter(dynamics_summary.max_rna, dynamics_summary.dynamic_range_rna) 

# %%
# Add selected columns
columns_to_add = ['peak_rna', 'peak_atac', 'dynamic_range_rna', 'dynamic_range_atac']
for col in columns_to_add:
    genes_by_meta_groups_filt.obs[col] = genes_by_meta_groups_filt.obs_names.map(dynamics_summary[col])
    
genes_by_meta_groups_filt.obs.head()

# %%
# Extract numeric values from timepoints
genes_by_meta_groups_filt.obs['peak_rna_numeric'] = genes_by_meta_groups_filt.obs['peak_rna'].str.extract('(\d+)').astype(float)
genes_by_meta_groups_filt.obs['peak_atac_numeric'] = genes_by_meta_groups_filt.obs['peak_atac'].str.extract('(\d+)').astype(float)


# %%
# Create a figure with two panels
# fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# RNA peaks
sc.pl.umap(genes_by_meta_groups_filt, 
           color=['peak_rna_numeric','peak_atac_numeric'],
           cmap='viridis',
           title='Peak RNA timepoint',
           # ax=ax1,
           # show=False,
           vmin=10,  # minimum timepoint
           vmax=24)  # maximum timepoint

plt.tight_layout()
plt.show()


# %%
# Normalize dynamic range to use as alpha values (between 0 and 1)
def normalize_for_alpha(values, min_alpha=0.2, max_alpha=1.0):
    min_val = values.min()
    max_val = values.max()
    normalized = (values - min_val) / (max_val - min_val)
    return normalized * (max_alpha - min_alpha) + min_alpha

# Create alpha values from dynamic ranges
genes_by_meta_groups_filt.obs['alpha_rna'] = normalize_for_alpha(genes_by_meta_groups_filt.obs['dynamic_range_rna'])
genes_by_meta_groups_filt.obs['alpha_atac'] = normalize_for_alpha(genes_by_meta_groups_filt.obs['dynamic_range_atac'])

# Plot with varying transparency
sc.pl.umap(genes_by_meta_groups_filt, 
           color=['peak_rna_numeric'],
           cmap='viridis',
           alpha=genes_by_meta_groups_filt.obs['alpha_rna'],  # for RNA plot
           title=['Peak RNA (alpha=dynamic range)'],
           vmin=10,
           vmax=24)

# %%
# Create a figure with two panels
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# RNA peaks with RNA dynamic range as alpha
sc.pl.umap(genes_by_meta_groups_filt, 
           color='peak_rna_numeric',
           cmap='viridis',
           alpha=genes_by_meta_groups_filt.obs['alpha_rna'],
           title='Peak RNA timepoint\n(transparency = RNA dynamic range)',
           ax=ax1,
           show=False,
           vmin=10,
           vmax=24)

# ATAC peaks with ATAC dynamic range as alpha
sc.pl.umap(genes_by_meta_groups_filt, 
           color='peak_atac_numeric',
           cmap='viridis',
           alpha=genes_by_meta_groups_filt.obs['alpha_atac'],
           title='Peak ATAC timepoint\n(transparency = ATAC dynamic range)',
           ax=ax2,
           show=False,
           vmin=10,
           vmax=24)

plt.tight_layout()
plt.savefig(figpath+"gene_umaps_peak_timepoints.png")
plt.savefig(figpath+"gene_umaps_peak_timepoints.pdf")
plt.show()

# %%
genes_by_meta_groups_filt[genes_by_meta_groups_filt.obs_names=="cdx1a"].obs

# %%
genes_by_meta_groups_filt[genes_by_meta_groups_filt.obs_names=="slc4a1a"].obs

# %% [markdown]
# ## "log-normalized" counts

# %%
# # Create dictionaries to store parsed information
# parsed_info = [parse_var_names(var_name) for var_name in genes_by_meta_groups_filt.var_names]
# df_info = pd.DataFrame(parsed_info, columns=['celltype', 'timepoint', 'modality'], index=genes_by_meta_groups_filt.var_names)

# conver the counts layer to "raw" (log-normalization, then averaged over metacells )
genes_by_meta_groups_filt.X = genes_by_meta_groups_filt.layers["raw"]

# Convert adata to dataframe for easier manipulation
expression_df = pd.DataFrame(genes_by_meta_groups_filt.X, 
                             columns=genes_by_meta_groups_filt.var_names,
                             index=genes_by_meta_groups_filt.obs_names)
expression_df

# %%
# First, let's correctly identify unique celltypes and timepoints
unique_celltypes = df_info['celltype'].unique()
unique_timepoints = df_info['timepoint'].unique()

# Compute averages
rna_df = split_by_modality(expression_df, df_info, 'rna')
atac_df = split_by_modality(expression_df, df_info, 'atac')

rna_celltype_avg = average_over_celltypes(rna_df, df_info, 'rna')
atac_celltype_avg = average_over_celltypes(atac_df, df_info, 'atac')

# Print summary
print(f"Number of unique celltypes: {len(unique_celltypes)}")
print(f"Number of timepoints: {len(unique_timepoints)}")
print("\nUnique celltypes:")
print(sorted(unique_celltypes))
print("\nTimepoints:")
print(sorted(unique_timepoints))

print("\nRNA averages shape (genes x timepoints):", rna_celltype_avg.shape)
print("ATAC averages shape (genes x timepoints):", atac_celltype_avg.shape)
print("\nFirst few rows of RNA averages:")
print(rna_celltype_avg.head())
print("\nFirst few rows of ATAC averages:")
print(atac_celltype_avg.head())

# %%
# Analyze distributions
rna_stats, rna_skew = analyze_distribution(rna_df, df_info, 'rna')
atac_stats, atac_skew = analyze_distribution(atac_df, df_info, 'atac')

print("Number of highly skewed genes at each timepoint (RNA):")
print(rna_skew)
print("\nNumber of highly skewed genes at each timepoint (ATAC):")
print(atac_skew)

# Plot comparison
plt.figure(figsize=(10, 5))
plt.scatter(rna_stats['mean'], rna_stats['median'], alpha=0.1)
plt.plot([rna_stats.min().min(), rna_stats.max().max()], 
         [rna_stats.min().min(), rna_stats.max().max()], 'r--')
plt.xlabel('Mean')
plt.ylabel('Median')
plt.title('Mean vs Median Comparison')
plt.show()


# %%
# Function to compute "median" across celltypes for each timepoint
def median_over_celltypes(df, df_info, modality):
    result_dict = {}
    
    for tp in sorted(unique_timepoints):
        # Get all columns for this timepoint and modality
        mask = (df_info['timepoint'] == tp) & (df_info['modality'] == modality)
        tp_cols = df_info[mask].index
        # Average across celltypes for this timepoint
        result_dict[tp] = np.median(df[tp_cols], axis=1)
    
    return pd.DataFrame(result_dict, index=df.index)

rna_celltype_median = median_over_celltypes(rna_df, df_info, 'rna')
atac_celltype_median = median_over_celltypes(atac_df, df_info, 'atac')


# %% [markdown]
# In a separate UMAP, we plot where the peaks are with color, and use transparency to visualize a measure of ‘peak contrast’: the peak value minus mean of other points,  divided by std dev. of all points minus the maximal point. This will be high when there is a well defined peak, and low when there is not really a peak.

# %%
# Function to find peak timepoint and compute dynamic range
def compute_peaks_and_range(row):
    # Find peak timepoint
    peak_timepoint = row.idxmax()
    # Compute dynamic metrics
    std_dev = row.std()
    variance = row.var()
    dynamic_range = row.max() - row.min()  # max-min difference
    mean = row.mean()
    max_value = row.max()
    return pd.Series({
        'peak_timepoint': peak_timepoint,
        'std_dev': std_dev,
        'variance': variance,
        'dynamic_range': dynamic_range,
        'mean':mean,
        'max':max_value
    })


# %%
# Compute metrics for RNA
rna_dynamics = rna_celltype_avg.apply(compute_peaks_and_range, axis=1)
rna_dynamics = rna_dynamics.rename(columns={
    'peak_timepoint': 'peak_rna',
    'std_dev': 'std_dev_rna',
    'variance': 'variance_rna',
    'dynamic_range': 'dynamic_range_rna',
    'mean':'mean_rna',
    'max':'max_rna'
})

# Compute metrics for ATAC
atac_dynamics = atac_celltype_avg.apply(compute_peaks_and_range, axis=1)
atac_dynamics = atac_dynamics.rename(columns={
    'peak_timepoint': 'peak_atac',
    'std_dev': 'std_dev_atac',
    'variance': 'variance_atac',
    'dynamic_range': 'dynamic_range_atac',
    'mean':'mean_atac',
    'max':'max_atac'
})


# %%
# Combine the results
dynamics_summary = pd.concat([rna_dynamics, atac_dynamics], axis=1)

# Print first few rows
print("Dynamics summary for first few genes:")
print(dynamics_summary.head())

# Optional: Summary statistics
print("\nSummary of peak timepoints:")
print("RNA peaks:\n", dynamics_summary['peak_rna'].value_counts())
print("\nATAC peaks:\n", dynamics_summary['peak_atac'].value_counts())

# %%
# Add selected columns
columns_to_add = ['peak_rna', 'peak_atac', 
                  'dynamic_range_rna', 'dynamic_range_atac', 
                  'variance_rna', 'variance_atac']
for col in columns_to_add:
    genes_by_meta_groups_filt.obs[col] = genes_by_meta_groups_filt.obs_names.map(dynamics_summary[col])
    
genes_by_meta_groups_filt.obs.head()

# %%
# Extract numeric values from timepoints
genes_by_meta_groups_filt.obs['peak_rna_numeric'] = genes_by_meta_groups_filt.obs['peak_rna'].str.extract('(\d+)').astype(float)
genes_by_meta_groups_filt.obs['peak_atac_numeric'] = genes_by_meta_groups_filt.obs['peak_atac'].str.extract('(\d+)').astype(float)


# %%
# Create a figure with two panels
# fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# RNA peaks
sc.pl.umap(genes_by_meta_groups_filt, 
           color=['peak_rna_numeric','peak_atac_numeric'],
           cmap='viridis',
           title='Peak RNA timepoint',
           # ax=ax1,
           # show=False,
           vmin=10,  # minimum timepoint
           vmax=24)  # maximum timepoint

plt.tight_layout()
plt.show()


# %%
# Normalize dynamic range to use as alpha values (between 0 and 1)
def normalize_for_alpha(values, min_alpha=0.2, max_alpha=1.0):
    min_val = values.min()
    max_val = values.max()
    normalized = (values - min_val) / (max_val - min_val)
    return normalized * (max_alpha - min_alpha) + min_alpha

# robust normalization accounting for the outliers
def normalize_for_alpha_robust(values, min_alpha=0.2, max_alpha=1.0, lower_percentile=1, upper_percentile=99):
    # Get percentile values
    min_val = np.percentile(values, lower_percentile)
    max_val = np.percentile(values, upper_percentile)
    
    # Clip values to percentile range
    clipped = np.clip(values, min_val, max_val)
    
    # Normalize
    normalized = (clipped - min_val) / (max_val - min_val)
    return normalized * (max_alpha - min_alpha) + min_alpha


# %%
# Create alpha values from dynamic ranges
genes_by_meta_groups_filt.obs['alpha_rna'] = normalize_for_alpha(genes_by_meta_groups_filt.obs['dynamic_range_rna'])
genes_by_meta_groups_filt.obs['alpha_atac'] = normalize_for_alpha(genes_by_meta_groups_filt.obs['dynamic_range_atac'])

# Plot with varying transparency
sc.pl.umap(genes_by_meta_groups_filt, 
           color=['peak_rna_numeric','peak_atac_numeric'],
           cmap='viridis',
           alpha=genes_by_meta_groups_filt.obs['alpha_rna'],  # for RNA plot
           title=['Peak RNA (alpha=dynamic_range_rna)', 'Peak ATAC (alpha=dynamic_range_rna)'],
           vmin=10,
           vmax=24)
plt.savefig(figpath + "gene_umap_color_peak_timepoints_rna_atac_alpha_dynamic_range.png")
plt.savefig(figpath + "gene_umap_color_peak_timepoints_rna_atac_alpha_dynamic_range.pdf")

# %%
# Create alpha values from "variance"
genes_by_meta_groups_filt.obs['alpha_rna'] = normalize_for_alpha_robust(genes_by_meta_groups_filt.obs['variance_rna'])
genes_by_meta_groups_filt.obs['alpha_atac'] = normalize_for_alpha_robust(genes_by_meta_groups_filt.obs['variance_atac'])

# Plot with varying transparency
sc.pl.umap(genes_by_meta_groups_filt, 
           color=['peak_rna_numeric','peak_atac_numeric'],
           cmap='viridis',
           alpha=genes_by_meta_groups_filt.obs['alpha_rna'],  # for RNA plot
           title=['Peak RNA (alpha=variance_rna)', 'Peak ATAC (alpha=variance_rna)'],
           vmin=10,
           vmax=24)

plt.savefig(figpath + "gene_umap_color_peak_timepoints_rna_atac_alpha_variance.png")
plt.savefig(figpath + "gene_umap_color_peak_timepoints_rna_atac_alpha_variance.pdf")

# %% [markdown]
# ### instead of "mean" over celltypes, computing "median" over celltypes
#
# - 

# %%
# Compute metrics for RNA
rna_dynamics_median = rna_celltype_median.apply(compute_peaks_and_range, axis=1)
rna_dynamics_median = rna_dynamics_median.rename(columns={
    'peak_timepoint': 'peak_rna',
    'std_dev': 'std_dev_rna',
    'variance': 'variance_rna',
    'dynamic_range': 'dynamic_range_rna',
    'mean':'mean_rna',
    'max':'max_rna'
})

# Compute metrics for ATAC
atac_dynamics_median = atac_celltype_median.apply(compute_peaks_and_range, axis=1)
atac_dynamics_median = atac_dynamics_median.rename(columns={
    'peak_timepoint': 'peak_atac',
    'std_dev': 'std_dev_atac',
    'variance': 'variance_atac',
    'dynamic_range': 'dynamic_range_atac',
    'mean':'mean_atac',
    'max':'max_atac'
})


# %%
# Combine the results
dynamics_median_summary = pd.concat([rna_dynamics_median, atac_dynamics_median], axis=1)

# Print first few rows
print("Dynamics summary for first few genes:")
print(dynamics_median_summary.head())

# Optional: Summary statistics
print("\nSummary of peak timepoints:")
print("RNA peaks:\n", dynamics_median_summary['peak_rna'].value_counts())
print("\nATAC peaks:\n", dynamics_median_summary['peak_atac'].value_counts())

# %%
# create a temporary adata
genes_by_meta_groups_filt_temp = genes_by_meta_groups_filt.copy()

# %%
# Add selected columns
columns_to_add = ['peak_rna', 'peak_atac', 
                  'dynamic_range_rna', 'dynamic_range_atac', 
                  'variance_rna', 'variance_atac']
for col in columns_to_add:
    genes_by_meta_groups_filt_temp.obs[col] = genes_by_meta_groups_filt_temp.obs_names.map(dynamics_summary[col])
    
genes_by_meta_groups_filt_temp.obs.head()

# %%
# Extract numeric values from timepoints
genes_by_meta_groups_filt_temp.obs['peak_rna_numeric'] = genes_by_meta_groups_filt_temp.obs['peak_rna'].str.extract('(\d+)').astype(float)
genes_by_meta_groups_filt_temp.obs['peak_atac_numeric'] = genes_by_meta_groups_filt_temp.obs['peak_atac'].str.extract('(\d+)').astype(float)


# %%
# Create a figure with two panels
# fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# RNA peaks
sc.pl.umap(genes_by_meta_groups_filt_temp, 
           color=['peak_rna_numeric','peak_atac_numeric'],
           cmap='viridis',
           title='Peak RNA timepoint',
           # ax=ax1,
           # show=False,
           vmin=10,  # minimum timepoint
           vmax=24)  # maximum timepoint

plt.tight_layout()
plt.show()

# %%
# computing the "alpha" using the variance
genes_by_meta_groups_filt_temp.obs['alpha_rna'] = normalize_for_alpha_robust(genes_by_meta_groups_filt_temp.obs['variance_rna'])
genes_by_meta_groups_filt_temp.obs['alpha_atac'] = normalize_for_alpha_robust(genes_by_meta_groups_filt_temp.obs['variance_atac'])

# Plot with varying transparency
sc.pl.umap(genes_by_meta_groups_filt_temp, 
           color=['peak_rna_numeric','peak_atac_numeric'],
           cmap='viridis',
           alpha=genes_by_meta_groups_filt.obs['alpha_rna'],  # for RNA plot
           title=['Peak RNA (alpha=dynamic_range_rna)', 'Peak ATAC (alpha=dynamic_range_rna)'],
           vmin=10,
           vmax=24)
plt.savefig(figpath + "gene_umap_median_color_peak_timepoints_rna_atac_alpha_variance.png")
plt.savefig(figpath + "gene_umap_median_color_peak_timepoints_rna_atac_alpha_variance.pdf")


# %% [markdown]
# ### Mean/Median over timepoints does not make a huge difference. Sticking with mean.

# %%
def compute_peak_metrics(row):
    # Find peak timepoint and value
    peak_timepoint = row.idxmax()
    peak_value = row.max()
    
    # Calculate mean and std of non-peak points
    other_points = row.drop(peak_timepoint)
    mean_others = other_points.mean()
    std_others = other_points.std()
    
    # Calculate peak contrast
    peak_contrast = (peak_value - mean_others) / std_others if std_others > 0 else 0
    
    # Extract numeric timepoint from string (assuming format like "10hpf")
    peak_time_numeric = float(peak_timepoint.split('hpf')[0])
    
    return pd.Series({
        'peak_timepoint': peak_timepoint,
        'peak_time_numeric': peak_time_numeric,
        'peak_value': peak_value,
        'peak_contrast': peak_contrast,
        'mean_others': mean_others,
        'std_others': std_others
    })

# Apply to RNA and ATAC data
rna_peaks = rna_celltype_avg.apply(compute_peak_metrics, axis=1)
atac_peaks = atac_celltype_avg.apply(compute_peak_metrics, axis=1)

# Add to adata object
genes_by_meta_groups_filt.obs['peak_rna_numeric'] = rna_peaks['peak_time_numeric']
genes_by_meta_groups_filt.obs['peak_atac_numeric'] = atac_peaks['peak_time_numeric']
genes_by_meta_groups_filt.obs['peak_contrast_rna'] = rna_peaks['peak_contrast']
genes_by_meta_groups_filt.obs['peak_contrast_atac'] = atac_peaks['peak_contrast']


# %%
genes_by_meta_groups_filt.obs['peak_atac_numeric'].value_counts()

# %%
plt.bar([10,12,14,16,19,24],[4,1054,26,14,3970,0])
plt.yscale("log")
plt.xticks([10,12,14,16,19,24])
plt.xlabel("hours post fertilization (hpf)")
plt.ylabel("number of genes peaking at each timepoint")

# %%
genes_by_meta_groups_filt.write

# %%
genes_by_meta_groups_filt[genes_by_meta_groups_filt.obs['peak_atac_numeric']==12.0].obs

# %%
plt.scatter(genes_by_meta_groups_filt.obs['peak_contrast_atac'], 
            genes_by_meta_groups_filt.obs['peak_contrast_rna'])


# %%
# Normalize peak contrast for alpha values
def normalize_for_alpha_robust(values, min_alpha=0.1, max_alpha=0.9):
    min_val = np.percentile(values, 5)
    max_val = np.percentile(values, 95)
    clipped = np.clip(values, min_val, max_val)
    normalized = (clipped - min_val) / (max_val - min_val)
    return normalized * (max_alpha - min_alpha) + min_alpha

# Create alpha values from peak contrast
genes_by_meta_groups_filt.obs['alpha_rna'] = normalize_for_alpha_robust(genes_by_meta_groups_filt.obs['peak_contrast_rna'])
genes_by_meta_groups_filt.obs['alpha_atac'] = normalize_for_alpha_robust(genes_by_meta_groups_filt.obs['peak_contrast_atac'])


# %%
# Create UMAP plots
sc.pl.umap(genes_by_meta_groups_filt, 
           color=['peak_rna_numeric'],
           cmap='viridis',
           alpha=genes_by_meta_groups_filt.obs['alpha_rna'],
           title=['RNA peak time\n(alpha = peak contrast)'],
           vmin=10,vmax=24,
           save="_gene_median_color_peak_timepoints_rna_alpha_peak_contrast.png")

# %%
# Create UMAP plots
sc.pl.umap(genes_by_meta_groups_filt, 
           color=['peak_atac_numeric'],
           cmap='viridis',
           alpha=genes_by_meta_groups_filt.obs['alpha_atac'],
           title=['ATAC peak time\n(alpha = peak contrast)'],
           vmin=10,
           vmax=24,
           save="_gene_median_color_peak_timepoints_atac_alpha_peak_contrast.png")


# %% [markdown]
# ## "gradient" of RNA or ATAC over timepoints (averaged over celltypes for each gene)
#
# - 

# %%
def compute_temporal_trends(row):
    # Convert timepoints to numeric values
    timepoints = np.array([10, 12, 14, 16, 19, 24])  # your timepoints
    expression = row.values
    
    # Compute linear regression
    slope, intercept, r_value, p_value, std_err = stats.linregress(timepoints, expression)
    
    # Compute R-squared
    r_squared = r_value**2
    
    # Additional metrics
    dynamic_range = row.max() - row.min()
    
    return pd.Series({
        'slope': slope,  # positive = increasing, negative = decreasing
        'p_value': p_value,  # statistical significance
        'r_squared': r_squared,  # goodness of fit
        'dynamic_range': dynamic_range,
        'std_err': std_err,  # standard error of the slope
        'trend': 'increasing' if slope > 0 and p_value < 0.05 else 
                'decreasing' if slope < 0 and p_value < 0.05 else 
                'no_trend'
    })


# %%
# without any thresholding with p-values nor R-squared values
def compute_temporal_trends(row):
    # Convert timepoints to numeric values
    timepoints = np.array([10, 12, 14, 16, 19, 24])  # your timepoints
    expression = row.values
    
    # Compute linear regression
    slope, intercept, r_value, p_value, std_err = stats.linregress(timepoints, expression)
    
    # Compute R-squared
    r_squared = r_value**2
    
    # Additional metrics
    dynamic_range = row.max() - row.min()
    
    return pd.Series({
        'slope': slope,  # positive = increasing, negative = decreasing
        'p_value': p_value,  # statistical significance
        'r_squared': r_squared,  # goodness of fit
        'dynamic_range': dynamic_range,
        'std_err': std_err,  # standard error of the slope
        'trend': 'increasing' if slope > 0 else 
                'decreasing' if slope < 0 else 
                'zero'
    })


# %%
# Compute trends for RNA and ATAC
rna_trends = rna_celltype_avg.apply(compute_temporal_trends, axis=1)
atac_trends = atac_celltype_avg.apply(compute_temporal_trends, axis=1)

# Rename columns
rna_trends = rna_trends.add_prefix('rna_')
atac_trends = atac_trends.add_prefix('atac_')

# Combine results
dynamics_summary = pd.concat([rna_trends, atac_trends], axis=1)

# Filter for significant trends
significant_genes = dynamics_summary[
    ((dynamics_summary['rna_p_value'] < 0.05) | 
     (dynamics_summary['atac_p_value'] < 0.05))
]

# Visualize trends
plt.figure(figsize=(10, 6))
plt.scatter(dynamics_summary['rna_slope'], 
           dynamics_summary['atac_slope'],
           alpha=0.5,
           c=-np.log10(dynamics_summary['rna_p_value']))
plt.axhline(y=0, color='gray', linestyle='--')
plt.axvline(x=0, color='gray', linestyle='--')
plt.xlabel('RNA slope')
plt.ylabel('ATAC slope')
plt.colorbar(label='-log10(p-value)')
plt.title('RNA vs ATAC temporal trends')
plt.show()



# %%
# Visualize trends
plt.figure(figsize=(10, 6))
plt.scatter(dynamics_summary['rna_slope'], 
           dynamics_summary['atac_slope'],
           alpha=0.5,
           c=dynamics_summary['rna_r_squared'], cmap="magma")
plt.axhline(y=0, color='gray', linestyle='--')
plt.axvline(x=0, color='gray', linestyle='--')
plt.xlabel('RNA slope')
plt.ylabel('ATAC slope')
plt.colorbar(label='r_squared')
plt.title('RNA vs ATAC temporal trends')
plt.show()

# %%
# plt.figure(figsize=(12, 12))

# # Main scatter plot
# scatter = plt.scatter(dynamics_summary['rna_slope'],
#                      dynamics_summary['atac_slope'],
#                      alpha=0.5,
#                      c=-np.log10(dynamics_summary['rna_p_value']))

# # Function to get extreme points in each quadrant
# def get_extreme_points(df, quadrant, n=10):
#     if quadrant == 'both_increasing':
#         subset = df[(df['rna_slope'] > 0) & (df['atac_slope'] > 0)]
#         return subset.nlargest(n, ['rna_slope', 'atac_slope'].sum())
#     elif quadrant == 'both_decreasing':
#         subset = df[(df['rna_slope'] < 0) & (df['atac_slope'] < 0)]
#         return subset.nsmallest(n, ['rna_slope', 'atac_slope'].sum())
#     elif quadrant == 'rna_up_atac_down':
#         subset = df[(df['rna_slope'] > 0) & (df['atac_slope'] < 0)]
#         return subset.nlargest(n, lambda x: x['rna_slope'] - x['atac_slope'])
#     elif quadrant == 'rna_down_atac_up':
#         subset = df[(df['rna_slope'] < 0) & (df['atac_slope'] > 0)]
#         return subset.nlargest(n, lambda x: x['atac_slope'] - x['rna_slope'])

# # Add labels for extreme points in each quadrant
# for quadrant in ['both_increasing', 'both_decreasing', 'rna_up_atac_down', 'rna_down_atac_up']:
#     extreme_points = get_extreme_points(dynamics_summary, quadrant)
#     for idx in extreme_points.index:
#         plt.annotate(idx, 
#                     (dynamics_summary.loc[idx, 'rna_slope'], 
#                      dynamics_summary.loc[idx, 'atac_slope']),
#                     xytext=(5, 5), textcoords='offset points',
#                     fontsize=8, alpha=0.7)

# plt.axhline(y=0, color='gray', linestyle='--')
# plt.axvline(x=0, color='gray', linestyle='--')
# plt.xlabel('RNA slope')
# plt.ylabel('ATAC slope')
# plt.colorbar(scatter, label='-log10(p-value)')
# plt.title('RNA vs ATAC temporal trends')
# plt.tight_layout()
# plt.show()

# # Print the extreme genes and their values
# for quadrant in ['both_increasing', 'both_decreasing', 'rna_up_atac_down', 'rna_down_atac_up']:
#     print(f"\nTop 10 genes in {quadrant}:")
#     extreme_points = get_extreme_points(dynamics_summary, quadrant)
#     for idx in extreme_points.index:
#         print(f"{idx}: RNA slope={dynamics_summary.loc[idx, 'rna_slope']:.3f}, "
#               f"ATAC slope={dynamics_summary.loc[idx, 'atac_slope']:.3f}, "
#               f"p-value={dynamics_summary.loc[idx, 'rna_p_value']:.3e}")

# %%
# Visualize trends
plt.figure(figsize=(10, 6))
plt.scatter(dynamics_summary['rna_slope'], 
           -np.log10(dynamics_summary['rna_p_value']),
           alpha=0.5)
plt.axhline(y=0, color='gray', linestyle='--')
plt.axvline(x=0, color='gray', linestyle='--')
plt.xlabel('RNA slope')
plt.ylabel('-log10(p-value)')
# plt.colorbar(label='-log10(p-value)')
plt.title('RNA vs ATAC temporal trends')
plt.show()


# %%
# Convert p-values to alpha values (using -log10 transformation)
def p_value_to_alpha(p_values, min_alpha=0.1, max_alpha=1.0, threshold=0.05):
    # Set minimum p-value to avoid log(0)
    min_p = 1e-300
    p_values = np.maximum(p_values, min_p)
    
    # Transform to -log10 scale
    neg_log_p = -np.log10(p_values)
    
    # Normalize between min_alpha and max_alpha
    # Values less significant than threshold will get min_alpha
    normalized = np.where(p_values > threshold, 
                         min_alpha,
                         ((neg_log_p - np.min(neg_log_p)) / 
                          (np.max(neg_log_p) - np.min(neg_log_p)) * 
                          (max_alpha - min_alpha) + min_alpha))
    
    return normalized

# Create alpha values from p-values
genes_by_meta_groups_filt.obs['alpha_rna'] = p_value_to_alpha(genes_by_meta_groups_filt.obs['rna_p_value'])
genes_by_meta_groups_filt.obs['alpha_atac'] = p_value_to_alpha(genes_by_meta_groups_filt.obs['atac_p_value'])

# %%
dynamics_summary["rna_r_squared"]

# %%
# Create alpha values from r_squared values (goodness-of-fit)
genes_by_meta_groups_filt.obs['alpha_rna'] = dynamics_summary["rna_r_squared"]
genes_by_meta_groups_filt.obs['alpha_atac'] = dynamics_summary["atac_r_squared"]

# %%
dynamics_summary.rna_trend.value_counts()

# %%
# You could also use these trends in your UMAP visualization:
genes_by_meta_groups_filt.obs['rna_slope'] = dynamics_summary['rna_slope']
genes_by_meta_groups_filt.obs['rna_p_value'] = dynamics_summary['rna_p_value']
genes_by_meta_groups_filt.obs['atac_slope'] = dynamics_summary['atac_slope']
genes_by_meta_groups_filt.obs['atac_p_value'] = dynamics_summary['atac_p_value']
genes_by_meta_groups_filt.obs['rna_r_squared'] = dynamics_summary['rna_r_squared']
genes_by_meta_groups_filt.obs['atac_r_squared'] = dynamics_summary['atac_r_squared']
genes_by_meta_groups_filt.obs['rna_trend'] = dynamics_summary['rna_trend']
genes_by_meta_groups_filt.obs['atac_trend'] = dynamics_summary['atac_trend']

sc.pl.umap(genes_by_meta_groups_filt, 
           color=['atac_slope', 'rna_slope'],
           cmap='RdBu_r', vmin=-0.3, vmax=0.3,
           save="slopes_rna_atac_over_time.pdf") # red for positive slopes, blue for negative)  # center colormap at 0

# %%
sc.pl.umap(genes_by_meta_groups_filt, 
           color=['rna_slope', 'atac_slope'],
           cmap='RdBu_r', vmin=-0.3, vmax=0.3,
           alpha=genes_by_meta_groups_filt.obs['alpha_rna'],
           save="slopes_rna_atac_over_time_alpha_r_squared.png") # red for positive slopes, blue for negative)  # center colormap at 0

# %%
sc.pl.umap(genes_by_meta_groups_filt, 
           color=['rna_slope'],
           cmap='RdBu_r', vmin=-0.15, vmax=0.15,
           alpha=genes_by_meta_groups_filt.obs['alpha_rna'],
           save="slopes_rna_over_time_alpha_r_squared.png") # red for positive slopes, blue for negative)  # center colormap at 0

# %%
sc.pl.umap(genes_by_meta_groups_filt, 
           color=['atac_slope'],
           cmap='RdBu_r', vmin=-0.15, vmax=0.15,
           alpha=genes_by_meta_groups_filt.obs['alpha_atac'],
           save="slopes_atac_over_time_alpha_r_squared.png")

# %%
dynamics_summary.atac_slope.sort_values(ascending=True).index[0:20]

# %%
# 1. Get interesting genes from different categories
# Your list of interesting genes
interesting_genes = ["cdx1a",'foxh1', 'asb11', 'rims2b', 'eve1', 'vox', 'vent', 'kif26ab', 'tbx16',
       'cyp26a1', 'hnf1ba', 'rasd2', 'her11', 'zgc:158291', 'dkk1b', 'apoeb',
       'noto', 'her5', 'foxi1', 'lcp2b', 'lamb1a']

# Alternative version with better label placement
import adjustText  # if you want to avoid label overlap

interesting_mask = genes_by_meta_groups_filt.obs.index.isin(interesting_genes)


plt.figure(figsize=(12, 12))
scatter_all = plt.scatter(genes_by_meta_groups_filt.obsm['X_umap'][:, 0],
                         genes_by_meta_groups_filt.obsm['X_umap'][:, 1],
                         c='lightgray',
                         alpha=0.2,
                         s=10)

scatter_highlights = plt.scatter(genes_by_meta_groups_filt.obsm['X_umap'][interesting_mask, 0],
                               genes_by_meta_groups_filt.obsm['X_umap'][interesting_mask, 1],
                               c='red',
                               s=50)

texts = []
for gene in interesting_genes:
    idx = genes_by_meta_groups_filt.obs.index.get_loc(gene)
    texts.append(plt.text(genes_by_meta_groups_filt.obsm['X_umap'][idx, 0],
                         genes_by_meta_groups_filt.obsm['X_umap'][idx, 1],
                         gene,
                         fontsize=8,
                         color='darkred'))

adjustText.adjust_text(texts, arrowprops=dict(arrowstyle='->', color='darkred', alpha=0.5))

plt.title('UMAP with highlighted genes (adjusted labels)')
plt.xlabel('UMAP1')
plt.ylabel('UMAP2')
plt.tight_layout()
plt.show()

# %%
# 1. Get interesting genes from different categories
# Your list of interesting genes
interesting_genes = ["cdx1a",'slc4a1a']

# Alternative version with better label placement
import adjustText  # if you want to avoid label overlap

interesting_mask = genes_by_meta_groups_filt.obs.index.isin(interesting_genes)


plt.figure(figsize=(12, 12))
scatter_all = plt.scatter(genes_by_meta_groups_filt.obsm['X_umap'][:, 0],
                         genes_by_meta_groups_filt.obsm['X_umap'][:, 1],
                         c='lightgray',
                         alpha=0.2,
                         s=10)

scatter_highlights = plt.scatter(genes_by_meta_groups_filt.obsm['X_umap'][interesting_mask, 0],
                               genes_by_meta_groups_filt.obsm['X_umap'][interesting_mask, 1],
                               c='red',
                               s=50)

texts = []
for gene in interesting_genes:
    idx = genes_by_meta_groups_filt.obs.index.get_loc(gene)
    texts.append(plt.text(genes_by_meta_groups_filt.obsm['X_umap'][idx, 0],
                         genes_by_meta_groups_filt.obsm['X_umap'][idx, 1],
                         gene,
                         fontsize=8,
                         color='darkred'))

adjustText.adjust_text(texts, arrowprops=dict(arrowstyle='->', color='darkred', alpha=0.5))

plt.title('UMAP with highlighted genes (adjusted labels)')
plt.xlabel('UMAP1')
plt.ylabel('UMAP2')
plt.tight_layout()
plt.show()


# %%
def plot_gene_trends(gene_list, rna_celltype_avg, atac_celltype_avg, dynamics_summary):
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    n_genes = len(gene_list)
    
    # Create subplot grid
    fig, axes = plt.subplots(n_genes, 2, figsize=(12, 4*n_genes))
    if n_genes == 1:
        axes = axes.reshape(1, -1)
    
    for i, gene in enumerate(gene_list):
        # Plot RNA trend
        ax1 = axes[i, 0]
        rna_values = rna_celltype_avg.loc[gene]
        
        # Plot actual values
        ax1.plot(timepoints, rna_values, 'o-', color='blue', label='RNA data')
        
        # Plot linear fit
        rna_slope = dynamics_summary.loc[gene, 'rna_slope']
        rna_intercept = np.mean(rna_values) - rna_slope * np.mean(timepoints)
        fit_line = rna_slope * timepoints + rna_intercept
        ax1.plot(timepoints, fit_line, '--', color='red', 
                label=f'RNA fit (slope={rna_slope:.3f}, R²={dynamics_summary.loc[gene, "rna_r_squared"]:.2f})')
        
        ax1.set_title(f'{gene} - RNA')
        ax1.set_xlabel('Time (hpf)')
        ax1.set_ylabel('Expression')
        ax1.legend()
        
        # Plot ATAC trend
        ax2 = axes[i, 1]
        atac_values = atac_celltype_avg.loc[gene]
        
        # Plot actual values
        ax2.plot(timepoints, atac_values, 'o-', color='blue', label='ATAC data')
        
        # Plot linear fit
        atac_slope = dynamics_summary.loc[gene, 'atac_slope']
        atac_intercept = np.mean(atac_values) - atac_slope * np.mean(timepoints)
        fit_line = atac_slope * timepoints + atac_intercept
        ax2.plot(timepoints, fit_line, '--', color='red', 
                label=f'ATAC fit (slope={atac_slope:.3f}, R²={dynamics_summary.loc[gene, "atac_r_squared"]:.2f})')
        
        ax2.set_title(f'{gene} - ATAC')
        ax2.set_xlabel('Time (hpf)')
        ax2.set_ylabel('Activity')
        ax2.legend()
    
    plt.tight_layout()
    plt.show()

# Example usage:
# 1. Get interesting genes from different categories
# Your list of interesting genes
interesting_genes = ["cdx1a",'foxh1', 'asb11', 'rims2b', 'eve1', 'vox', 'vent', 'kif26ab', 'tbx16',
       'cyp26a1', 'hnf1ba', 'rasd2', 'her11', 'zgc:158291', 'dkk1b', 'apoeb',
       'noto', 'her5', 'foxi1', 'lcp2b', 'lamb1a']

# For finding additional genes with strong trends
# Genes with strong positive correlation (both increasing)
pos_corr = dynamics_summary[
    (dynamics_summary['rna_slope'] > 0) & 
    (dynamics_summary['atac_slope'] > 0) &
    (dynamics_summary['rna_r_squared'] > 0.5) &
    (dynamics_summary['atac_r_squared'] > 0.5)
]
pos_corr['total_slope'] = pos_corr['rna_slope'] + pos_corr['atac_slope']
top_pos = pos_corr.nlargest(2, 'total_slope')
interesting_genes.extend(top_pos.index)

# Genes with strong negative correlation (opposite trends)
neg_corr = dynamics_summary[
    (dynamics_summary['rna_slope'] > 0) & 
    (dynamics_summary['atac_slope'] < 0) &
    (dynamics_summary['rna_r_squared'] > 0.5) &
    (dynamics_summary['atac_r_squared'] > 0.5)
]
neg_corr['slope_diff'] = abs(neg_corr['rna_slope']) + abs(neg_corr['atac_slope'])
top_neg = neg_corr.nlargest(2, 'slope_diff')
interesting_genes.extend(top_neg.index)

# Plot trends for these genes
plot_gene_trends(interesting_genes, rna_celltype_avg, atac_celltype_avg, dynamics_summary)

# %%

# %%

# %%

# %%
genes_by_meta_groups_filt.obs["peak_atac_numeric"].value_counts()

# %%
genes_by_meta_groups_filt[genes_by_meta_groups_filt.obs["peak_atac_numeric"]==19].obs_names

# %%
# Plot trends for these genes
interesting_genes = ["cep85l","ccne2"]
plot_gene_trends(interesting_genes, rna_celltype_avg, atac_celltype_avg, dynamics_summary)


# %%
def plot_gene_trends(gene_list, rna_celltype_avg, atac_celltype_avg, dynamics_summary):
   timepoints = np.array([10, 12, 14, 16, 19, 24])
   n_genes = len(gene_list)
   
   # Create subplot grid
   fig, axes = plt.subplots(n_genes, 2, figsize=(12, 4*n_genes))
   if n_genes == 1:
       axes = axes.reshape(1, -1)
   
   for i, gene in enumerate(gene_list):
       # Plot RNA trend
       ax1 = axes[i, 0]
       rna_values = rna_celltype_avg.loc[gene]
       
       ax1.plot(timepoints, rna_values, 'o-', color='blue', label='RNA data')
       
       rna_slope = dynamics_summary.loc[gene, 'rna_slope']
       rna_intercept = np.mean(rna_values) - rna_slope * np.mean(timepoints)
       fit_line = rna_slope * timepoints + rna_intercept
       ax1.plot(timepoints, fit_line, '--', color='red', 
               label=f'RNA fit (slope={rna_slope:.3f}, R²={dynamics_summary.loc[gene, "rna_r_squared"]:.2f})')
       
       ax1.set_title(f'{gene} - RNA')
       ax1.set_xlabel('Time (hpf)')
       ax1.set_ylabel('Expression')
       ax1.legend()
       
       # Plot ATAC trend
       ax2 = axes[i, 1]
       atac_values = atac_celltype_avg.loc[gene]
       
       ax2.plot(timepoints, atac_values, 'o-', color='blue', label='ATAC data')
       
       atac_slope = dynamics_summary.loc[gene, 'atac_slope']
       atac_intercept = np.mean(atac_values) - atac_slope * np.mean(timepoints)
       fit_line = atac_slope * timepoints + atac_intercept
       ax2.plot(timepoints, fit_line, '--', color='red', 
               label=f'ATAC fit (slope={atac_slope:.3f}, R²={dynamics_summary.loc[gene, "atac_r_squared"]:.2f})')
       
       ax2.set_title(f'{gene} - ATAC')
       ax2.set_xlabel('Time (hpf)')
       ax2.set_ylabel('Activity')
       ax2.legend()
   
   plt.tight_layout()
   return fig

# # Usage:
# fig = plot_gene_trends(interesting_genes, rna_celltype_avg, atac_celltype_avg, dynamics_summary)
# plt.savefig('gene_trends.pdf', bbox_inches='tight')
# plt.savefig('gene_trends.png', bbox_inches='tight', dpi=300)
# plt.show()


# %%
# Plot trends for these genes
interesting_genes = ["acta1b","slc4a1a","noto"]
fig = plot_gene_trends(interesting_genes, rna_celltype_avg, atac_celltype_avg, dynamics_summary)
plt.savefig(figpath + "gene_trends_rna_atac_avg_time.pdf", bbox_inches="tight")
plt.show()


# %%
def plot_gene_trends_with_peak(gene_list, rna_celltype_avg, atac_celltype_avg, dynamics_summary):
   timepoints = np.array([10, 12, 14, 16, 19, 24])
   n_genes = len(gene_list)
   
   fig, axes = plt.subplots(n_genes, 2, figsize=(12, 4*n_genes))
   if n_genes == 1:
       axes = axes.reshape(1, -1)
   
   for i, gene in enumerate(gene_list):
       # RNA plot
       ax1 = axes[i, 0]
       rna_values = rna_celltype_avg.loc[gene]
       
       # Calculate peak contrast
       peak_value = rna_values.max()
       other_points = rna_values[rna_values != peak_value]
       mean_others = other_points.mean()
       std_others = other_points.std()  # std of points excluding peak
       peak_contrast = (peak_value - mean_others) / std_others
       
       # Plot data and fit
       ax1.plot(timepoints, rna_values, 'o-', color='blue', label='RNA data')
       ax1.axhspan(mean_others - std_others, mean_others + std_others, 
                  color='grey', alpha=0.2, label='±1 std of non-peak points')
       
       # Highlight peak
       peak_idx = rna_values.argmax()
       ax1.plot(timepoints[peak_idx], peak_value, 'o', color='red', 
               markersize=10, label=f'Peak at {timepoints[peak_idx]}hpf')
       
       # Linear fit
       rna_slope = dynamics_summary.loc[gene, 'rna_slope']
       rna_intercept = np.mean(rna_values) - rna_slope * np.mean(timepoints)
       fit_line = rna_slope * timepoints + rna_intercept
       ax1.plot(timepoints, fit_line, '--', color='red', 
               label=f'RNA fit (slope={rna_slope:.3f}, R²={dynamics_summary.loc[gene, "rna_r_squared"]:.2f})')
       
       ax1.set_title(f'{gene} - RNA\npeak contrast={peak_contrast:.2f}')
       ax1.set_xlabel('Time (hpf)')
       ax1.set_ylabel('Expression')
       ax1.legend()
       
       # ATAC plot
       ax2 = axes[i, 1]
       atac_values = atac_celltype_avg.loc[gene]
       
       # Calculate peak contrast for ATAC
       peak_value = atac_values.max()
       other_points = atac_values[atac_values != peak_value]
       mean_others = other_points.mean()
       std_others = other_points.std()
       peak_contrast = (peak_value - mean_others) / std_others
       
       ax2.plot(timepoints, atac_values, 'o-', color='blue', label='ATAC data')
       ax2.axhspan(mean_others - std_others, mean_others + std_others, 
                  color='grey', alpha=0.2, label='±1 std of non-peak points')
       
       peak_idx = atac_values.argmax()
       ax2.plot(timepoints[peak_idx], peak_value, 'o', color='red', 
               markersize=10, label=f'Peak at {timepoints[peak_idx]}hpf')
       
       atac_slope = dynamics_summary.loc[gene, 'atac_slope']
       atac_intercept = np.mean(atac_values) - atac_slope * np.mean(timepoints)
       fit_line = atac_slope * timepoints + atac_intercept
       ax2.plot(timepoints, fit_line, '--', color='red', 
               label=f'ATAC fit (slope={atac_slope:.3f}, R²={dynamics_summary.loc[gene, "atac_r_squared"]:.2f})')
       
       ax2.set_title(f'{gene} - ATAC\npeak contrast={peak_contrast:.2f}')
       ax2.set_xlabel('Time (hpf)')
       ax2.set_ylabel('Activity')
       ax2.legend()
   
   plt.tight_layout()
   return fig

# Usage
fig = plot_gene_trends_with_peak(interesting_genes, rna_celltype_avg, atac_celltype_avg, dynamics_summary)
plt.savefig(figpath + 'gene_trends_with_peaks.pdf', bbox_inches='tight')
plt.show()

# %%

# %%

# %%

# %%

# %%

# %%

# %%

# %% [markdown]
# ### [Advanced] instead of linear fit, performing a curve fit (more complex dynamics)
#

# %%
from scipy.optimize import curve_fit

def compute_complex_temporal_trends(row):
    # Convert timepoints to numeric values
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    expression = row.values
    
    # Linear fit
    slope, intercept, r_value, p_value, std_err = stats.linregress(timepoints, expression)
    linear_r_squared = r_value**2
    
    # Quadratic fit
    def quadratic(x, a, b, c):
        return a * x**2 + b * x + c
    
    try:
        popt, pcov = curve_fit(quadratic, timepoints, expression)
        a, b, c = popt
        
        # Compute R-squared for quadratic fit
        residuals = expression - quadratic(timepoints, a, b, c)
        ss_res = np.sum(residuals**2)
        ss_tot = np.sum((expression - np.mean(expression))**2)
        quad_r_squared = 1 - (ss_res / ss_tot)
        
        # Find peak/trough of quadratic
        peak_time = -b/(2*a) if a != 0 else None
        
        # Determine pattern
        if quad_r_squared > linear_r_squared and quad_r_squared > 0.6:  # Quadratic fit is better
            if peak_time is not None and min(timepoints) < peak_time < max(timepoints):
                if a > 0:
                    pattern = 'valley'  # U-shaped
                else:
                    pattern = 'peak'    # Inverse U-shaped
            else:
                pattern = 'increasing' if slope > 0 else 'decreasing'
        else:  # Linear fit is better
            if p_value < 0.05:
                pattern = 'increasing' if slope > 0 else 'decreasing'
            else:
                pattern = 'no_trend'
                
        return pd.Series({
            'linear_slope': slope,
            'linear_p_value': p_value,
            'linear_r_squared': linear_r_squared,
            'quad_a': a,  # quadratic coefficient
            'quad_r_squared': quad_r_squared,
            'pattern': pattern,
            'peak_time': peak_time,
            'dynamic_range': max(expression) - min(expression),
            'confidence': max(linear_r_squared, quad_r_squared)
        })
    
    except:
        return pd.Series({
            'linear_slope': slope,
            'linear_p_value': p_value,
            'linear_r_squared': linear_r_squared,
            'quad_a': np.nan,
            'quad_r_squared': np.nan,
            'pattern': 'no_trend',
            'peak_time': np.nan,
            'dynamic_range': max(expression) - min(expression),
            'confidence': linear_r_squared
        })


# %%
def compute_complex_temporal_trends(row):
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    expression = row.values
    
    # Linear fit
    slope, intercept, r_value, p_value, std_err = stats.linregress(timepoints, expression)
    linear_r_squared = r_value**2
    
    # Quadratic fit
    def quadratic(x, a, b, c):
        return a * x**2 + b * x + c
    
    try:
        popt, pcov = curve_fit(quadratic, timepoints, expression)
        a, b, c = popt
        
        # Compute R-squared for quadratic fit
        residuals = expression - quadratic(timepoints, a, b, c)
        ss_res = np.sum(residuals**2)
        ss_tot = np.sum((expression - np.mean(expression))**2)
        quad_r_squared = 1 - (ss_res / ss_tot)
        
        # Find peak/trough of quadratic
        peak_time = -b/(2*a) if a != 0 else None
        
        # More lenient classification
        # Check if there's a clear peak or valley in the actual data
        max_idx = np.argmax(expression)
        min_idx = np.argmin(expression)
        
        # Define early, middle, late ranges
        early = timepoints < 14
        middle = (timepoints >= 14) & (timepoints < 19)
        late = timepoints >= 19
        
        # Determine pattern based on data shape
        if max_idx > 0 and max_idx < len(timepoints)-1:  # peak not at endpoints
            pattern = 'peak'
        elif min_idx > 0 and min_idx < len(timepoints)-1:  # valley not at endpoints
            pattern = 'valley'
        else:  # monotonic trends
            if expression[-1] > expression[0]:
                pattern = 'increasing'
            else:
                pattern = 'decreasing'
        
        # Calculate confidence based on both fits and dynamic range
        dynamic_range = max(expression) - min(expression)
        relative_change = dynamic_range / np.mean(expression)
        confidence = max(linear_r_squared, quad_r_squared) * relative_change
                
        return pd.Series({
            'linear_slope': slope,
            'linear_p_value': p_value,
            'linear_r_squared': linear_r_squared,
            'quad_a': a,
            'quad_r_squared': quad_r_squared,
            'pattern': pattern,
            'peak_time': peak_time,
            'dynamic_range': dynamic_range,
            'relative_change': relative_change,
            'confidence': confidence
        })
    
    except:
        return pd.Series({
            'linear_slope': slope,
            'linear_p_value': p_value,
            'linear_r_squared': linear_r_squared,
            'quad_a': np.nan,
            'quad_r_squared': np.nan,
            'pattern': 'no_trend',
            'peak_time': np.nan,
            'dynamic_range': max(expression) - min(expression),
            'relative_change': np.nan,
            'confidence': linear_r_squared
        })

# Visualize example genes for each pattern
def plot_example_patterns(trends_df, expression_df, n_examples=3):
    patterns = trends_df['pattern'].unique()
    fig, axes = plt.subplots(len(patterns), n_examples, figsize=(15, 3*len(patterns)))
    
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    
    for i, pattern in enumerate(patterns):
        # Get examples with highest confidence
        pattern_genes = trends_df[trends_df['pattern'] == pattern].nlargest(n_examples, 'confidence').index
        
        for j, gene in enumerate(pattern_genes):
            ax = axes[i,j]
            expression = expression_df.loc[gene]
            ax.plot(timepoints, expression, 'o-')
            ax.set_title(f'{pattern}: {gene}')
            ax.set_xlabel('Time (hpf)')
            ax.set_ylabel('Expression')
            
    plt.tight_layout()
    plt.show()


# %%
# Apply to your data
rna_trends = rna_celltype_avg.apply(compute_complex_temporal_trends, axis=1)
atac_trends = atac_celltype_avg.apply(compute_complex_temporal_trends, axis=1)

# %%
# Visualize patterns
plt.figure(figsize=(12, 6))
pattern_counts = rna_trends['pattern'].value_counts()
plt.bar(pattern_counts.index, pattern_counts.values)
plt.title('Distribution of RNA Expression Patterns')
plt.xticks(rotation=45)
plt.show()



# %%
# First, create a custom color palette for the patterns
pattern_colors = {
    'peak': '#FF6B6B',      # red for peak
    'valley': '#4ECDC4',    # teal for valley
    'increasing': '#45B7D1', # blue for increasing
    'decreasing': '#96CEB4', # green for decreasing
    'no_trend': '#CCCCCC'   # gray for no trend
}

# Normalize confidence scores to use as alpha
def normalize_confidence(values, min_alpha=0.2, max_alpha=0.9):
    # Can use the robust normalization we discussed earlier
    min_val = np.percentile(values, 5)
    max_val = np.percentile(values, 95)
    clipped = np.clip(values, min_val, max_val)
    normalized = (clipped - min_val) / (max_val - min_val)
    return normalized * (max_alpha - min_alpha) + min_alpha

# Add to UMAP visualization
genes_by_meta_groups_filt.obs['rna_pattern'] = rna_trends['pattern']
genes_by_meta_groups_filt.obs['rna_confidence'] = rna_trends['confidence']


# Add normalized confidence scores
genes_by_meta_groups_filt.obs['alpha_confidence'] = normalize_confidence(genes_by_meta_groups_filt.obs['rna_confidence'])

# %%
# Plot with pattern colors and confidence as alpha
sc.pl.umap(genes_by_meta_groups_filt,
           color='rna_pattern',
           alpha=genes_by_meta_groups_filt.obs['alpha_confidence'],
           title='RNA Expression Patterns\n(alpha = confidence)')



# %%
# Visualize example genes for each pattern
def plot_example_patterns(trends_df, expression_df, n_examples=3):
    patterns = trends_df['pattern'].unique()
    fig, axes = plt.subplots(len(patterns), n_examples, figsize=(15, 3*len(patterns)))
    
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    
    for i, pattern in enumerate(patterns):
        # Get examples with highest confidence
        pattern_genes = trends_df[trends_df['pattern'] == pattern].nlargest(n_examples, 'confidence').index
        
        for j, gene in enumerate(pattern_genes):
            ax = axes[i,j]
            expression = expression_df.loc[gene]
            ax.plot(timepoints, expression, 'o-')
            ax.set_title(f'{pattern}: {gene}')
            ax.set_xlabel('Time (hpf)')
            ax.set_ylabel('Expression')
            
    plt.tight_layout()
    plt.show()
    
plot_example_patterns(rna_trends, rna_celltype_avg)


# %%
# Optional: Plot example genes for each pattern
def plot_example_patterns(trends_df, expression_df, n_examples=3):
    patterns = trends_df['pattern'].unique()
    fig, axes = plt.subplots(len(patterns), n_examples, figsize=(15, 3*len(patterns)))
    
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    
    for i, pattern in enumerate(patterns):
        # Get top genes by confidence for this pattern
        pattern_genes = trends_df[trends_df['pattern'] == pattern].nlargest(n_examples, 'confidence').index
        
        for j, gene in enumerate(pattern_genes):
            ax = axes[i,j]
            expression = expression_df.loc[gene]
            ax.plot(timepoints, expression, 'o-')
            ax.set_title(f'{pattern}: {gene}')
            ax.set_xlabel('Time (hpf)')
            ax.set_ylabel('Expression')
            
    plt.tight_layout()
    plt.show()

plot_example_patterns(rna_trends, rna_celltype_avg)


# %%

# %%
def compute_binned_temporal_trends(row):
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    expression = row.values
    
    # Create bins
    early_bin = np.mean(expression[0:2])    # 10, 12 hpf
    middle_bin = np.mean(expression[2:4])   # 14, 16 hpf
    late_bin = np.mean(expression[4:6])     # 19, 24 hpf
    
    # Calculate differences between bins
    early_to_mid = middle_bin - early_bin
    mid_to_late = late_bin - middle_bin
    
    # Define threshold for meaningful change
    threshold = 0.1 * np.std(expression)  # Can adjust this threshold
    
    # Determine pattern based on binned values
    if middle_bin > early_bin and middle_bin > late_bin:
        pattern = 'peak'
    elif middle_bin < early_bin and middle_bin < late_bin:
        pattern = 'valley'
    elif early_bin < middle_bin < late_bin and abs(early_to_mid) > threshold and abs(mid_to_late) > threshold:
        pattern = 'increasing'
    elif early_bin > middle_bin > late_bin and abs(early_to_mid) > threshold and abs(mid_to_late) > threshold:
        pattern = 'decreasing'
    else:
        pattern = 'no_trend'
    
    # Calculate confidence score based on effect size
    dynamic_range = max(expression) - min(expression)
    mean_expression = np.mean(expression)
    relative_change = dynamic_range / mean_expression if mean_expression != 0 else 0
    
    # Calculate how well the pattern fits (difference between bins)
    if pattern in ['peak', 'valley']:
        confidence = min(abs(middle_bin - early_bin), abs(middle_bin - late_bin)) / mean_expression
    else:
        confidence = min(abs(early_to_mid), abs(mid_to_late)) / mean_expression
    
    return pd.Series({
        'pattern': pattern,
        'early_bin': early_bin,
        'middle_bin': middle_bin,
        'late_bin': late_bin,
        'confidence': confidence,
        'relative_change': relative_change,
        'dynamic_range': dynamic_range
    })

# Apply to your data
rna_trends = rna_celltype_avg.apply(compute_binned_temporal_trends, axis=1)
atac_trends = atac_celltype_avg.apply(compute_binned_temporal_trends, axis=1)


# %%
# Visualization function for example patterns
def plot_example_patterns(trends_df, expression_df, n_examples=3):
    patterns = ['peak', 'valley', 'increasing', 'decreasing', 'no_trend']
    fig, axes = plt.subplots(len(patterns), n_examples, figsize=(15, 3*len(patterns)))
    
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    
    for i, pattern in enumerate(patterns):
        # Get examples with highest confidence
        pattern_genes = trends_df[trends_df['pattern'] == pattern].nlargest(n_examples, 'confidence').index
        
        for j, gene in enumerate(pattern_genes):
            ax = axes[i,j]
            expression = expression_df.loc[gene]
            
            # Plot actual values
            ax.plot(timepoints, expression, 'o-', label='Expression')
            
            # Plot binned values
            bin_centers = [11, 15, 21.5]  # Center of each bin
            bin_values = [trends_df.loc[gene, 'early_bin'],
                         trends_df.loc[gene, 'middle_bin'],
                         trends_df.loc[gene, 'late_bin']]
            ax.plot(bin_centers, bin_values, 'r--', label='Binned average')
            
            ax.set_title(f'{pattern}: {gene}')
            ax.set_xlabel('Time (hpf)')
            ax.set_ylabel('Expression')
            if i == 0 and j == 0:
                ax.legend()
            
    plt.tight_layout()
    plt.show()

# Add to UMAP visualization
genes_by_meta_groups_filt.obs['rna_pattern'] = rna_trends['pattern']
genes_by_meta_groups_filt.obs['rna_confidence'] = rna_trends['confidence']

# Plot patterns on UMAP
pattern_colors = {
    'peak': '#FF6B6B',
    'valley': '#4ECDC4',
    'increasing': '#45B7D1',
    'decreasing': '#96CEB4',
    'no_trend': '#CCCCCC'
}

# %%
# Add normalized confidence scores
genes_by_meta_groups_filt.obs['alpha_confidence'] = normalize_confidence(genes_by_meta_groups_filt.obs['rna_confidence'])

# Plot with pattern colors and confidence as alpha
sc.pl.umap(genes_by_meta_groups_filt,
           color='rna_pattern',
           alpha=genes_by_meta_groups_filt.obs['alpha_confidence'],
           title='RNA Expression Patterns\n(alpha = confidence)')

# %%
plot_example_patterns(rna_trends, rna_celltype_avg)


# %%
def compute_signal_to_noise(row):
    mean_expr = np.mean(row)
    std_expr = np.std(row)
    cv = std_expr / mean_expr if mean_expr > 0 else float('inf')  # Coefficient of variation
    return cv



# %% [markdown]
# ### Using 4 bins instead of 3 (0, 5-10, 15-20, and 30 somites)
#
#

# %%
def compute_four_bin_temporal_trends(row):
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    expression = row.values
    
    # Create four bins
    bin1 = expression[0]              # 10 hpf
    bin2 = np.mean(expression[1:3])   # 12, 14 hpf
    bin3 = np.mean(expression[3:5])   # 16, 19 hpf
    bin4 = expression[5]              # 24 hpf
    
    # Calculate bin-to-bin differences
    diff1_2 = bin2 - bin1
    diff2_3 = bin3 - bin2
    diff3_4 = bin4 - bin3
    
    # Calculate variance-based threshold
    std_dev = np.std(expression)
    mean_expr = np.mean(expression)
    cv = std_dev / mean_expr if mean_expr != 0 else float('inf')
    
    # Define thresholds
    noise_threshold = 1.0 * std_dev  # changes smaller than 1 std dev are considered noise
    cv_threshold = 1.5               # high coefficient of variation indicates noisy data
    
    # Check if data is too noisy
    if cv > cv_threshold:
        pattern = 'no_trend'
        confidence = 0
    else:
        # Determine pattern based on binned values and noise threshold
        # For peak pattern
        if (bin2 > bin1 and bin2 > bin3) or (bin3 > bin2 and bin3 > bin4):
            pattern = 'peak'
            confidence = max(abs(bin2 - bin1), abs(bin3 - bin2), abs(bin3 - bin4)) / mean_expr
        
        # For valley pattern
        elif (bin2 < bin1 and bin2 < bin3) or (bin3 < bin2 and bin3 < bin4):
            pattern = 'valley'
            confidence = max(abs(bin2 - bin1), abs(bin3 - bin2), abs(bin3 - bin4)) / mean_expr
        
        # For increasing/decreasing patterns
        else:
            # Calculate overall trend
            total_change = bin4 - bin1
            
            if abs(total_change) < noise_threshold:
                pattern = 'no_trend'
                confidence = 0
            else:
                # Count number of positive and negative changes
                pos_changes = sum(x > noise_threshold for x in [diff1_2, diff2_3, diff3_4])
                neg_changes = sum(x < -noise_threshold for x in [diff1_2, diff2_3, diff3_4])
                
                if pos_changes >= 2:
                    pattern = 'increasing'
                    confidence = abs(total_change) / mean_expr
                elif neg_changes >= 2:
                    pattern = 'decreasing'
                    confidence = abs(total_change) / mean_expr
                else:
                    pattern = 'no_trend'
                    confidence = 0
    
    return pd.Series({
        'pattern': pattern,
        'bin1': bin1,
        'bin2': bin2,
        'bin3': bin3,
        'bin4': bin4,
        'confidence': confidence,
        'cv': cv,
        'std_dev': std_dev,
        'mean_expr': mean_expr
    })

# Apply to your data
rna_trends = rna_celltype_avg.apply(compute_four_bin_temporal_trends, axis=1)
atac_trends = atac_celltype_avg.apply(compute_four_bin_temporal_trends, axis=1)



# %%
# Visualization function
def plot_example_patterns(trends_df, expression_df, n_examples=3):
    patterns = ['peak', 'valley', 'increasing', 'decreasing', 'no_trend']
    fig, axes = plt.subplots(len(patterns), n_examples, figsize=(15, 3*len(patterns)))
    
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    bin_centers = [10, 13, 17.5, 24]  # Centers of bins
    
    for i, pattern in enumerate(patterns):
        pattern_genes = trends_df[trends_df['pattern'] == pattern].nlargest(n_examples, 'confidence').index
        
        for j, gene in enumerate(pattern_genes):
            ax = axes[i,j]
            # Plot original values
            expression = expression_df.loc[gene]
            ax.plot(timepoints, expression, 'o-', label='Expression', alpha=0.7)
            
            # Plot binned values
            bin_values = [trends_df.loc[gene, f'bin{k}'] for k in range(1, 5)]
            ax.plot(bin_centers, bin_values, 'r--', label='Binned', linewidth=2)
            
            # Add std dev band
            std_dev = trends_df.loc[gene, 'std_dev']
            mean_expr = trends_df.loc[gene, 'mean_expr']
            ax.axhspan(mean_expr - std_dev, mean_expr + std_dev, 
                      color='gray', alpha=0.2, label='±1 std dev')
            
            ax.set_title(f'{pattern}: {gene}\nCV={trends_df.loc[gene, "cv"]:.2f}')
            ax.set_xlabel('Time (hpf)')
            ax.set_ylabel('Expression')
            if i == 0 and j == 0:
                ax.legend()
    
    plt.tight_layout()
    plt.show()

# Print pattern statistics
print("\nPattern distribution:")
pattern_counts = rna_trends['pattern'].value_counts()
for pattern, count in pattern_counts.items():
    print(f"{pattern}: {count} genes")


# %%
# 1. Plot example genes for each pattern
def plot_example_patterns(trends_df, expression_df, n_examples=3):
    patterns = ['peak', 'valley', 'increasing', 'decreasing', 'no_trend']
    fig, axes = plt.subplots(len(patterns), n_examples, figsize=(15, 3*len(patterns)))
    
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    bin_centers = [10, 13, 17.5, 24]  # Centers of bins
    
    for i, pattern in enumerate(patterns):
        # Get examples with highest confidence
        pattern_genes = trends_df[trends_df['pattern'] == pattern].nlargest(n_examples, 'confidence').index
        
        for j, gene in enumerate(pattern_genes):
            ax = axes[i,j]
            # Plot original values
            expression = expression_df.loc[gene]
            ax.plot(timepoints, expression, 'o-', label='Expression', alpha=0.7)
            
            # Plot binned values
            bin_values = [trends_df.loc[gene, f'bin{k}'] for k in range(1, 5)]
            ax.plot(bin_centers, bin_values, 'r--', label='Binned', linewidth=2)
            
            # Add std dev band
            std_dev = trends_df.loc[gene, 'std_dev']
            mean_expr = trends_df.loc[gene, 'mean_expr']
            ax.axhspan(mean_expr - std_dev, mean_expr + std_dev, 
                      color='gray', alpha=0.2, label='±1 std dev')
            
            ax.set_title(f'{pattern}: {gene}\nconf={trends_df.loc[gene, "confidence"]:.2f}')
            ax.set_xlabel('Time (hpf)')
            ax.set_ylabel('Expression')
            if i == 0 and j == 0:
                ax.legend()
    
    plt.tight_layout()
    plt.show()


# %%
# 2. UMAP visualization
# Add pattern and confidence to adata object
genes_by_meta_groups_filt.obs['rna_pattern'] = rna_trends['pattern']
genes_by_meta_groups_filt.obs['rna_confidence'] = rna_trends['confidence']

# Plot patterns on UMAP
pattern_colors = {
    'peak': '#FF6B6B',
    'valley': '#4ECDC4',
    'increasing': '#45B7D1',
    'decreasing': '#96CEB4',
    'no_trend': '#CCCCCC'
}

# Normalize confidence scores for alpha values
def normalize_confidence(values, min_alpha=0.2, max_alpha=0.9):
    # Use robust normalization with percentiles
    min_val = np.percentile(values, 5)
    max_val = np.percentile(values, 95)
    clipped = np.clip(values, min_val, max_val)
    normalized = (clipped - min_val) / (max_val - min_val)
    return normalized * (max_alpha - min_alpha) + min_alpha

# Add normalized confidence scores
genes_by_meta_groups_filt.obs['alpha_confidence'] = normalize_confidence(genes_by_meta_groups_filt.obs['rna_confidence'])


# %%
# Plot 1: Pattern colored UMAP
pattern_colors = {
    'decreasing': '#4C72B0',  # blue from Set2
    'increasing': '#DD8452',  # orange from Set2
    'no_trend': '#55A868',    # green from Set2
    'peak': '#C44E52',        # red from Set2
    'valley': '#8172B3'       # purple from Set2
}

sc.pl.umap(genes_by_meta_groups_filt,
           color='rna_pattern',
           palette="Set2",
           alpha=genes_by_meta_groups_filt.obs['alpha_confidence'],
           title='RNA Expression Patterns\n(alpha = confidence)')


# %%
plot_example_patterns(rna_trends, rna_celltype_avg)


# %% [markdown]
# ### modification of the definition of each class:
#
#

# %%
def compute_temporal_patterns(row):
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    expression = row.values
    
    # Create four bins
    bin1 = expression[0]              # 10 hpf
    bin2 = np.mean(expression[1:3])   # 12, 14 hpf
    bin3 = np.mean(expression[3:5])   # 16, 19 hpf
    bin4 = expression[5]              # 24 hpf
    
    bins = [bin1, bin2, bin3, bin4]
    
    # Calculate confidence metrics
    mean_expr = np.mean(expression)
    std_dev = np.std(expression)
    total_change = abs(bin4 - bin1)
    
    # Define patterns based on criteria
    if bin4 > max(bin1, bin2, bin3):  # last point highest
        pattern = 'increasing'
        confidence = total_change / mean_expr if mean_expr > 0 else 0
    elif bin1 > max(bin2, bin3, bin4):  # first point highest
        pattern = 'decreasing'
        confidence = total_change / mean_expr if mean_expr > 0 else 0
    elif min(bin2, bin3) > max(bin1, bin4):  # middle points higher than ends
        pattern = 'peak'
        confidence = (min(bin2, bin3) - max(bin1, bin4)) / mean_expr if mean_expr > 0 else 0
    elif max(bin2, bin3) < min(bin1, bin4):  # middle points lower than ends
        pattern = 'valley'
        confidence = (min(bin1, bin4) - max(bin2, bin3)) / mean_expr if mean_expr > 0 else 0
    else:
        pattern = 'no_trend'
        confidence = 0
    
    return pd.Series({
        'pattern': pattern,
        'bin1': bin1,
        'bin2': bin2,
        'bin3': bin3,
        'bin4': bin4,
        'confidence': confidence,
        'std_dev': std_dev,
        'mean_expr': mean_expr
    })


# %%
# Apply to your data
rna_trends = rna_celltype_avg.apply(compute_temporal_patterns, axis=1)
atac_trends = atac_celltype_avg.apply(compute_temporal_patterns, axis=1)


# %%
# Plot example patterns
def plot_example_patterns(trends_df, expression_df, n_examples=3):
    patterns = ['peak', 'valley', 'increasing', 'decreasing', 'no_trend']
    fig, axes = plt.subplots(len(patterns), n_examples, figsize=(15, 3*len(patterns)))
    
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    bin_centers = [10, 13, 17.5, 24]  # Centers of bins
    
    for i, pattern in enumerate(patterns):
        pattern_genes = trends_df[trends_df['pattern'] == pattern].nlargest(n_examples, 'confidence').index
        
        for j, gene in enumerate(pattern_genes):
            ax = axes[i,j]
            # Plot original values
            expression = expression_df.loc[gene]
            ax.plot(timepoints, expression, 'o-', label='Expression', alpha=0.7)
            
            # Plot binned values
            bin_values = [trends_df.loc[gene, f'bin{k}'] for k in range(1, 5)]
            ax.plot(bin_centers, bin_values, 'r--', label='Binned', linewidth=2)
            
            # Add std dev band
            std_dev = trends_df.loc[gene, 'std_dev']
            mean_expr = trends_df.loc[gene, 'mean_expr']
            ax.axhspan(mean_expr - std_dev, mean_expr + std_dev, 
                      color='gray', alpha=0.2, label='±1 std dev')
            
            ax.set_title(f'{pattern}: {gene}\nconf={trends_df.loc[gene, "confidence"]:.2f}')
            ax.set_xlabel('Time (hpf)')
            ax.set_ylabel('Expression')
            if i == 0 and j == 0:
                ax.legend()
    
    plt.tight_layout()
    plt.show()


# %%
plot_example_patterns(rna_trends, rna_celltype_avg)

# %%
# Add to UMAP visualization
genes_by_meta_groups_filt.obs['rna_pattern'] = rna_trends['pattern']
genes_by_meta_groups_filt.obs['rna_confidence'] = rna_trends['confidence']

# Add normalized confidence scores
genes_by_meta_groups_filt.obs['alpha_confidence'] = normalize_confidence(genes_by_meta_groups_filt.obs['rna_confidence'])

# %%
# Create custom color palette using Set2 colors
pattern_colors = {
    'decreasing': '#4C72B0',  # blue
    'increasing': '#DD8452',  # orange
    'no_trend': '#55A868',    # green
    'peak': '#C44E52',        # red
    'valley': '#8172B3'       # purple
}

# Plot UMAP
sc.pl.umap(genes_by_meta_groups_filt,
           color='rna_pattern',
           palette=pattern_colors,
           alpha=genes_by_meta_groups_filt.obs['alpha_confidence'],
           title='RNA Expression Patterns\n(alpha = confidence)')
plt.savefig(figpath + "gene_umap_trends_4bins.pdf")
plt.savefig(figpath + "gene_umap_trends_4bins.png")


# %%
def plot_example_patterns(trends_df, expression_df, n_examples=3, min_confidence=1.0, max_confidence=float('inf')):
    patterns = ['peak', 'valley', 'increasing', 'decreasing', 'no_trend']
    fig, axes = plt.subplots(len(patterns), n_examples, figsize=(15, 3*len(patterns)))
    
    timepoints = np.array([10, 12, 14, 16, 19, 24])
    bin_centers = [10, 13, 17.5, 24]
    
    for i, pattern in enumerate(patterns):
        # Filter for examples within confidence range
        high_conf_genes = trends_df[
            (trends_df['pattern'] == pattern) & 
            (trends_df['confidence'] >= min_confidence) &
            (trends_df['confidence'] <= max_confidence)
        ].nlargest(n_examples, 'confidence').index
        
        if len(high_conf_genes) == 0:
            print(f"No examples found for {pattern} with confidence between {min_confidence} and {max_confidence}")
        
        for j in range(n_examples):
            ax = axes[i,j]
            if j < len(high_conf_genes):
                gene = high_conf_genes[j]
                # Plot original values
                expression = expression_df.loc[gene]
                ax.plot(timepoints, expression, 'o-', label='Expression', alpha=0.7)
                
                # Plot binned values
                bin_values = [trends_df.loc[gene, f'bin{k}'] for k in range(1, 5)]
                ax.plot(bin_centers, bin_values, 'r--', label='Binned', linewidth=2)
                
                # Add std dev band
                std_dev = trends_df.loc[gene, 'std_dev']
                mean_expr = trends_df.loc[gene, 'mean_expr']
                ax.axhspan(mean_expr - std_dev, mean_expr + std_dev, 
                          color='gray', alpha=0.2, label='±1 std dev')
                
                ax.set_title(f'{pattern}: {gene}\nconf={trends_df.loc[gene, "confidence"]:.2f}')
            else:
                ax.set_title(f'No more {pattern} examples\nwith conf in [{min_confidence}, {max_confidence}]')
            
            ax.set_xlabel('Time (hpf)')
            ax.set_ylabel('Expression')
            if i == 0 and j == 0:
                ax.legend()
    
    plt.tight_layout()
    plt.show()


# %%
plot_example_patterns(rna_trends, rna_celltype_avg, n_examples=6, min_confidence=1)

# %%
# Print confidence distribution before plotting
print("Confidence distribution by pattern:")
for pattern in rna_trends['pattern'].unique():
    conf_stats = rna_trends[rna_trends['pattern'] == pattern]['confidence'].describe()
    print(f"\n{pattern}:")
    print(conf_stats)

# Then plot with confidence threshold
plot_example_patterns(rna_trends, rna_celltype_avg, n_examples=6, min_confidence=2.0, max_confidence=)  # adjust threshold as needed

# %%

# %%

# %% [markdown]
# ## plotting the gene expression/activity trends (averaged over genes from each leiden cluster across all celltypes) over time

# %%
# convert the counts back to "z-scored"
genes_by_meta_groups_filt.X = genes_by_meta_groups_filt.layers["z_score"].copy()


# %%
def compute_leiden_cluster_stats(adata, df_info, modality, leiden_col='leiden_0.7'):
    result_dict = {}
    
    # Group genes by leiden clusters
    unique_clusters = adata.obs[leiden_col].unique()
    
    for cluster in sorted(unique_clusters):
        # Get genes in this cluster
        cluster_mask = adata.obs[leiden_col] == cluster
        
        # Get expression data for these genes
        cluster_data = pd.DataFrame(
            adata[cluster_mask].X,
            columns=adata.var_names,
            index=adata.obs_names[cluster_mask]
        )
        
        # Process each celltype and timepoint
        for celltype in df_info['celltype'].unique():
            for timepoint in df_info['timepoint'].unique():
                # Get columns for this celltype, timepoint, and modality
                col_mask = (df_info['celltype'] == celltype) & \
                          (df_info['timepoint'] == timepoint) & \
                          (df_info['modality'] == modality)
                cols = df_info[col_mask].index
                
                if len(cols) > 0:  # if we have data for this combination
                    data = cluster_data[cols]
                    
                    # Store results with MultiIndex
                    result_dict[(cluster, timepoint, celltype)] = {
                        'median': data.median().median(),  # median across genes and columns
                        'mean': data.mean().mean(),
                        'std': data.std().std()
                    }
    
    # Convert to DataFrame with MultiIndex
    result_df = pd.DataFrame.from_dict(result_dict, orient='index')
    result_df.index = pd.MultiIndex.from_tuples(result_df.index, 
                                               names=['leiden_cluster', 'timepoint', 'celltype'])
    
    return result_df

# Function to plot dynamics for a specific celltype
def plot_celltype_dynamics(stats_df, celltype, metric='median', title=None):
    plt.figure(figsize=(10, 6))
    
    # Get data for this celltype
    celltype_data = stats_df.xs(celltype, level='celltype')[metric].unstack('timepoint')
    
    # Plot each leiden cluster
    for cluster in celltype_data.index:
        plt.plot(celltype_data.columns, celltype_data.loc[cluster], 
                marker='o', label=f'Cluster {cluster}')
    
    plt.title(f"{title or 'Dynamics'} - {celltype}")
    plt.xlabel('Timepoint')
    plt.ylabel(f'{metric} expression')
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plt.show()

# Compute statistics
rna_stats = compute_leiden_cluster_stats(genes_by_meta_groups_filt, df_info, 'rna')
atac_stats = compute_leiden_cluster_stats(genes_by_meta_groups_filt, df_info, 'atac')
    
# Example usage: Plot specific celltypes
celltypes_of_interest = ['NMPs', 'PSM']  # replace with your celltypes of interest

for celltype in celltypes_of_interest:
    # RNA dynamics
    plot_celltype_dynamics(rna_stats, celltype, title='RNA')
    # ATAC dynamics
    plot_celltype_dynamics(atac_stats, celltype, title='ATAC')


# %%
# Example usage: Plot specific celltypes
celltypes_of_interest = ['NMPs', 'hemangioblasts', 'muscle', 'notochord']  # replace with your celltypes of interest

for celltype in celltypes_of_interest:
    # RNA dynamics
    plot_celltype_dynamics(rna_stats, celltype, title='RNA')
    # ATAC dynamics
    plot_celltype_dynamics(atac_stats, celltype, title='ATAC')

# %%
# Compute statistics
rna_stats = compute_leiden_cluster_stats(genes_by_meta_groups_filt, df_info, 'rna')
atac_stats = compute_leiden_cluster_stats(genes_by_meta_groups_filt, df_info, 'atac')
    
# Example usage: Plot specific celltypes
celltypes_of_interest = ['NMPs', 'hemangioblasts', 'muscle', 'notochord'] # replace with your celltypes of interest

for celltype in celltypes_of_interest:
    # RNA dynamics
    plot_celltype_dynamics(rna_stats, celltype, title='RNA')
    # ATAC dynamics
    plot_celltype_dynamics(atac_stats, celltype, title='ATAC')

# %%

# %%

# %% [markdown]
# ### trends using log-normalized values (above was the z-scored)

# %%
# convert the counts back to "raw" (log-normalzied values)
genes_by_meta_groups_filt.X = genes_by_meta_groups_filt.layers["raw"].copy()

# %%
genes_by_meta_groups_filt.uns["leiden_0.7_colors"]

# %%
genes_by_meta_groups_filt.obs.celltype1.unique().tolist()


# %%
def compute_leiden_cluster_stats(adata, df_info, modality, leiden_col='leiden_0.7'):
    result_dict = {}
    
    # Group genes by leiden clusters
    unique_clusters = adata.obs[leiden_col].unique()
    
    for cluster in sorted(unique_clusters):
        # Get genes in this cluster
        cluster_mask = adata.obs[leiden_col] == cluster
        
        # Get expression data for these genes
        cluster_data = pd.DataFrame(
            adata[cluster_mask].X,
            columns=adata.var_names,
            index=adata.obs_names[cluster_mask]
        )
        
        # Process each celltype and timepoint
        for celltype in df_info['celltype'].unique():
            for timepoint in df_info['timepoint'].unique():
                # Get columns for this celltype, timepoint, and modality
                col_mask = (df_info['celltype'] == celltype) & \
                          (df_info['timepoint'] == timepoint) & \
                          (df_info['modality'] == modality)
                cols = df_info[col_mask].index
                
                if len(cols) > 0:  # if we have data for this combination
                    data = cluster_data[cols]
                    
                    # Store results with MultiIndex
                    result_dict[(cluster, timepoint, celltype)] = {
                        'median': data.median().median(),  # median across genes and columns
                        'mean': data.mean().mean(),
                        'std': data.std().std()
                    }
    
    # Convert to DataFrame with MultiIndex
    result_df = pd.DataFrame.from_dict(result_dict, orient='index')
    result_df.index = pd.MultiIndex.from_tuples(result_df.index, 
                                               names=['leiden_cluster', 'timepoint', 'celltype'])
    
    return result_df

# Function to plot dynamics for a specific celltype
def plot_celltype_dynamics(stats_df, celltype, metric='median', title=None, cluster_colors=None):
    plt.figure(figsize=(10, 6))
    
    # Get data for this celltype
    celltype_data = stats_df.xs(celltype, level='celltype')[metric].unstack('timepoint')
    
    # Plot each leiden cluster
    for cluster in celltype_data.index:
        plt.plot(celltype_data.columns, celltype_data.loc[cluster], 
                marker='o', label=f'Cluster {cluster}')
    
    plt.title(f"{title or 'Dynamics'} - {celltype}")
    plt.xlabel('Timepoint')
    plt.ylabel(f'{metric} expression')
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plt.show()

# # Compute statistics
# rna_stats = compute_leiden_cluster_stats(genes_by_meta_groups_filt, df_info, 'rna')
# atac_stats = compute_leiden_cluster_stats(genes_by_meta_groups_filt, df_info, 'atac')
    
# # Example usage: Plot specific celltypes
# celltypes_of_interest = ['NMPs','hatching_gland',
#                          'muscle','notochord',
#                          'hemangioblasts','differentiating neurons']  # replace with your celltypes of interest

# for celltype in celltypes_of_interest:
#     # RNA dynamics
#     plot_celltype_dynamics(rna_stats, celltype, metric="mean", title='RNA')
#     # ATAC dynamics
#     plot_celltype_dynamics(atac_stats, celltype, metric="mean", title='ATAC')



# %%
def plot_celltype_dynamics(stats_df, celltype, metric='median', error_type='sem', title=None, cluster_colors=None):
    """
    Plot dynamics with error bars
    
    Parameters:
    -----------
    stats_df : DataFrame with MultiIndex
    celltype : str, celltype to plot
    metric : str, 'median' or 'mean'
    error_type : str, 'std' or 'sem' for standard deviation or standard error of mean
    title : str, plot title
    cluster_colors : list of color hex codes
    """
    plt.figure(figsize=(10, 6))
    
    # Get data for this celltype
    celltype_data = stats_df.xs(celltype, level='celltype')
    timepoints = sorted(celltype_data.index.get_level_values('timepoint').unique())
    
    # Plot each leiden cluster
    for i, cluster in enumerate(celltype_data.index.get_level_values('leiden_cluster').unique()):
        # Get cluster data
        cluster_data = celltype_data.xs(cluster, level='leiden_cluster')
        
        # Get mean/median values
        values = [cluster_data.loc[tp, metric] for tp in timepoints]
        
        # Get error values
        if error_type == 'sem':
            errors = [cluster_data.loc[tp, 'std'] / np.sqrt(cluster_data.loc[tp, 'n_genes']) 
                     for tp in timepoints]
        else:  # std
            errors = [cluster_data.loc[tp, 'std'] for tp in timepoints]
        
        # Plot with error bars
        color = cluster_colors[i] if cluster_colors is not None else None
        plt.errorbar(timepoints, values, yerr=errors,
                    marker='o', label=f'Cluster {cluster}',
                    color=color, capsize=3)
    
    plt.title(f"{title or 'Dynamics'} - {celltype}")
    plt.xlabel('Time (hpf)')
    plt.ylabel(f'{metric} expression')
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plt.show()


# %%
def compute_leiden_cluster_stats(adata, df_info, modality, leiden_col='leiden_0.7'):
    result_dict = {}
    
    unique_clusters = adata.obs[leiden_col].unique()
    
    for cluster in sorted(unique_clusters):
        cluster_mask = adata.obs[leiden_col] == cluster
        
        cluster_data = pd.DataFrame(
            adata[cluster_mask].X,
            columns=adata.var_names,
            index=adata.obs_names[cluster_mask]
        )
        
        for celltype in df_info['celltype'].unique():
            for timepoint in df_info['timepoint'].unique():
                col_mask = (df_info['celltype'] == celltype) & \
                          (df_info['timepoint'] == timepoint) & \
                          (df_info['modality'] == modality)
                cols = df_info[col_mask].index
                
                if len(cols) > 0:
                    data = cluster_data[cols]
                    n_genes = len(data)  # number of genes for SEM calculation
                    
                    # Calculate mean and std across genes
                    gene_means = data.mean(axis=1)  # mean for each gene
                    
                    result_dict[(cluster, timepoint, celltype)] = {
                        'median': gene_means.median(),
                        'mean': gene_means.mean(),
                        'std': gene_means.std(),  # std across genes
                        'n_genes': n_genes
                    }
    
    result_df = pd.DataFrame.from_dict(result_dict, orient='index')
    result_df.index = pd.MultiIndex.from_tuples(result_df.index, 
                                               names=['leiden_cluster', 'timepoint', 'celltype'])
    
    return result_df

# Use the functions
rna_stats = compute_leiden_cluster_stats(genes_by_meta_groups_filt, df_info, 'rna')
cluster_colors = genes_by_meta_groups_filt.uns['leiden_0.7_colors']

# %%
# Use with the colors
cluster_colors = ['#1f77b4', '#ff7f0e', '#279e68', '#d62728', '#aa40fc', 
                 '#8c564b', '#e377c2', '#b5bd61', '#17becf', '#aec7e8', 
                 '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5']

# Plot with standard error of mean
plot_celltype_dynamics(rna_stats, celltype='NMPs', metric='mean', 
                      error_type='sem',  # or 'std' for standard deviation
                      title='RNA', 
                      cluster_colors=cluster_colors)

# %%
# Plot with standard error of mean
plot_celltype_dynamics(rna_stats, celltype='notochord', metric='mean', 
                      error_type='sem',  # or 'std' for standard deviation
                      title='RNA', 
                      cluster_colors=cluster_colors)

# %%
# Plot with standard error of mean
plot_celltype_dynamics(rna_stats, celltype='hemangioblasts', metric='mean', 
                      error_type='sem',  # or 'std' for standard deviation
                      title='RNA', 
                      cluster_colors=cluster_colors)

# %%

# %%
# Compute statistics
rna_stats = compute_leiden_cluster_stats(genes_by_meta_groups_filt, df_info, 'rna')
atac_stats = compute_leiden_cluster_stats(genes_by_meta_groups_filt, df_info, 'atac')

# Function to plot dynamics for a specific celltype
def plot_celltype_dynamics(stats_df, celltype, metric='median', title=None):
    plt.figure(figsize=(10, 6))
    
    # Get data for this celltype
    celltype_data = stats_df.xs(celltype, level='celltype')[metric].unstack('timepoint')
    
    # Plot each leiden cluster
    for cluster in celltype_data.index:
        plt.plot(celltype_data.columns, celltype_data.loc[cluster], 
                marker='o', label=f'Cluster {cluster}')
    
    plt.title(f"{title or 'Dynamics'} - {celltype}")
    plt.xlabel('Timepoint')
    plt.ylabel(f'{metric} expression')
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plt.show()

# Example usage: Plot specific celltypes
celltypes_of_interest = ['NMPs', 'PSM']  # replace with your celltypes of interest

for celltype in celltypes_of_interest:
    # RNA dynamics
    plot_celltype_dynamics(rna_stats, celltype, title='RNA')
    # ATAC dynamics
    plot_celltype_dynamics(atac_stats, celltype, title='ATAC')


# %%

# %%

# %% [markdown]
# ### dissection on specific cell-types (example)

# %%
hatching_gland_sub = genes_by_meta_groups_filt[genes_by_meta_groups_filt.obs["leiden_0.7"]==6]
hatching_gland_sub

# %%
# Subset variable names for RNA and ATAC expression
rna_vars = hatching_gland_sub.var_names[hatching_gland_sub.var_names.str.contains("hatching_gland_.*_rna")]
atac_vars = hatching_gland_sub.var_names[hatching_gland_sub.var_names.str.contains("hatching_gland_.*_atac")]

# Subset the AnnData object for RNA and ATAC
rna_data = hatching_gland_sub[:, rna_vars].X
atac_data = hatching_gland_sub[:, atac_vars].X

# compute the z-scores for each gene (along the metacells)
rna_data_zscore = stats.zscore(rna_data, axis=1)
atac_data_zscore = stats.zscore(atac_data, axis=1)

# Extract time points
timepoints = [var.split('_')[2] for var in rna_vars]  # Extracts the time component (e.g., "10hpf") from the var names
timepoints = np.array([int(tp.replace("hpf", "")) for tp in timepoints])  # Convert to integers (e.g., 10, 12, 14)

# Calculate mean expression and standard error over cells for each time point
rna_mean_expression = np.mean(rna_data_zscore, axis=0)
rna_sem_expression = np.std(rna_data_zscore, axis=0) / np.sqrt(rna_data_zscore.shape[0])

atac_mean_expression = np.mean(atac_data_zscore, axis=0)
atac_sem_expression = np.std(atac_data_zscore, axis=0) / np.sqrt(atac_data_zscore.shape[0])

# Plot RNA and ATAC expression trends with error bars
plt.figure(figsize=(10, 5))

# RNA trend with error bars
plt.errorbar(timepoints, rna_mean_expression, yerr=rna_sem_expression, label="RNA Expression", marker="o", color="blue", capsize=5)

# ATAC trend with error bars
plt.errorbar(timepoints, atac_mean_expression, yerr=atac_sem_expression, label="ATAC Expression", marker="o", color="red", capsize=5)

# Add labels and title
plt.xlabel("Time (hpf)")
plt.ylabel("Mean Expression ± SEM")
plt.title("RNA and ATAC Expression Trends Over Time (Hatching Gland)")
plt.legend()
plt.grid(False)
plt.show()

# %%
hemato_sub = genes_by_meta_groups_filt[genes_by_meta_groups_filt.obs["leiden_0.7"]==7]
hemato_sub.obs.head()

# %%
# Subset variable names for RNA and ATAC expression
rna_vars = hemato_sub.var_names[hemato_sub.var_names.str.contains("hematopoietic_vasculature.*_rna")]
atac_vars = hemato_sub.var_names[hemato_sub.var_names.str.contains("hematopoietic_vasculature.*_atac")]

# Subset the AnnData object for RNA and ATAC
rna_data = hemato_sub[:, rna_vars].X
atac_data = hemato_sub[:, atac_vars].X

# compute the z-scores for each gene (along the metacells)
rna_data_zscore = stats.zscore(rna_data, axis=1)
atac_data_zscore = stats.zscore(atac_data, axis=1)

# Extract time points
timepoints = [var.split('_')[2] for var in rna_vars]  # Extracts the time component (e.g., "10hpf") from the var names
timepoints = np.array([int(tp.replace("hpf", "")) for tp in timepoints])  # Convert to integers (e.g., 10, 12, 14)

# Calculate mean expression and standard error over cells for each time point
rna_mean_expression = np.mean(rna_data_zscore, axis=0)
rna_sem_expression = np.std(rna_data_zscore, axis=0) / np.sqrt(rna_data_zscore.shape[0])

atac_mean_expression = np.mean(atac_data_zscore, axis=0)
atac_sem_expression = np.std(atac_data_zscore, axis=0) / np.sqrt(atac_data_zscore.shape[0])

# Plot RNA and ATAC expression trends with error bars
plt.figure(figsize=(10, 5))

# RNA trend with error bars
plt.errorbar(timepoints, rna_mean_expression, yerr=rna_sem_expression, label="RNA Expression", marker="o", color="blue", capsize=5)

# ATAC trend with error bars
plt.errorbar(timepoints, atac_mean_expression, yerr=atac_sem_expression, label="ATAC Expression", marker="o", color="red", capsize=5)

# Add labels and title
plt.xlabel("Time (hpf)")
plt.ylabel("Mean Expression ± SEM")
plt.title("RNA and ATAC Expression Trends Over Time (Hatching Gland)")
plt.legend()
plt.grid(False)
plt.show()

# %%

# %% [markdown]
# ## [9/5/2025] ALL gene UMAP
#
# - we're re-computing the UMAP for ALL genes

# %%
combined_rna

# %%
combined_rna.obs.head()

# %%
import scipy
import pandas as pd
import scanpy as sc

def compute_group_averages(adata, group_by=['celltype', 'timepoint']):
    """
    Compute average expression grouped by cell type and timepoint, filling NaNs with 0.
    
    Parameters:
    -----------
    adata : AnnData
        Input AnnData object with observations containing group_by columns
    group_by : list
        Columns to group by (default: ['celltype', 'timepoint'])
        
    Returns:
    --------
    adata_grouped : AnnData
        New AnnData object with averaged expression values
    """
    # Convert sparse matrix to dense if needed
    X = adata.X.toarray() if scipy.sparse.issparse(adata.X) else adata.X
    
    # Create DataFrame with expression values
    exp_df = pd.DataFrame(
        X,
        index=adata.obs.index,
        columns=adata.var_names
    )
    
    # Add metadata columns for grouping
    for col in group_by:
        exp_df[col] = adata.obs[col]
    
    # Compute averages and fill NaNs with 0
    grouped_means = exp_df.groupby(group_by, observed=True)[adata.var_names].mean().fillna(0)
    
    # Handle MultiIndex properly by resetting it to columns
    grouped_means_reset = grouped_means.reset_index()
    
    # Create obs DataFrame with proper column names
    obs_df = grouped_means_reset[group_by].copy()
    obs_df.index = obs_df.index.astype(str)
    
    # Create new AnnData object with averaged values
    adata_grouped = sc.AnnData(
        X=grouped_means_reset[adata.var_names].values,
        obs=obs_df,
        var=adata.var.copy()
    )
    
    # Add group info to obs names
    if len(group_by) == 2:
        adata_grouped.obs_names = [f"{row[group_by[0]]}_{row[group_by[1]]}" 
                                   for _, row in obs_df.iterrows()]
    else:
        adata_grouped.obs_names = [f"{'_'.join([str(row[col]) for col in group_by])}" 
                                   for _, row in obs_df.iterrows()]
    
    # Print summary
    print("\nGrouping summary:")
    print(f"Original shape: {adata.shape}")
    print(f"Grouped shape: {adata_grouped.shape}")
    print(f"Number of zeros from NaN filling: {(adata_grouped.X == 0).sum()}")


# %%
# compute the average for "celltype", and "timepoint"
rna_meta_grouped = compute_group_averages(combined_rna, group_by=["celltype","timepoint"])
rna_meta_grouped

atac_meta_grouped = compute_group_averages(combined_atac, group_by=["celltype","timepoint"])
atac_meta_grouped

# %% [markdown]
#
# Grouping summary:
# Original shape: (1092, 24858)
# Grouped shape: (192, 24858)
# Number of zeros from NaN filling: 1867258
#
# Grouping summary:
# Original shape: (1092, 24858)
# Grouped shape: (192, 24858)
# Number of zeros from NaN filling: 579784
# AnnData object with n_obs × n_vars = 192 × 24858
#     obs: 'celltype', 'timepoint'

# %%
# save the "averaged" log-normalized counts into the layer
rna_meta_grouped.layers["raw"] = rna_meta_grouped.X.copy()
atac_meta_grouped.layers["raw"] = atac_meta_grouped.X.copy()

# %%
rna_meta_grouped.obs_names = rna_meta_grouped.obs_names + "_rna"
rna_meta_grouped.obs_names

# %%
atac_meta_grouped.obs_names = atac_meta_grouped.obs_names + "_atac"
atac_meta_grouped.obs_names

# %%
# filter for the 10K highly variagle genes from RNA gene expression (across single-cells)
rna_meta_grouped_filt = rna_meta_grouped[:,rna_meta_grouped.var_names.isin(list_hvgs_rna)]
atac_meta_grouped_filt = atac_meta_grouped[:,atac_meta_grouped.var_names.isin(list_hvgs_rna)]

# %%
rna_meta_grouped_filt

# %%

# %%
# import the adata (genes-by-celltype&timepoint, z-scored in adata.X, and saving the "raw" layers for the log-normalized counts)
genes_by_ct_tp = sc.read_h5ad("/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/data/processed_data/annotations/genes_by_celltypes_timepoints.h5ad")
genes_by_ct_tp

# %%
compute_top_celltypes_by_expression(rna_meta_ad, top_n=2)

# %%
import scipy as sci

# Function to compute the top cell type based on combined RNA + ATAC expression
def compute_top_celltype_by_combined_expression(rna_meta_ad, atac_meta_ad):
    # Convert sparse matrices to dense if necessary
    if sci.sparse.issparse(rna_meta_ad.X):
        rna_expr_values = pd.DataFrame(rna_meta_ad.X.toarray(), index=rna_meta_ad.obs.index, columns=rna_meta_ad.var.index)
    else:
        rna_expr_values = pd.DataFrame(rna_meta_ad.X, index=rna_meta_ad.obs.index, columns=rna_meta_ad.var.index)

    if sci.sparse.issparse(atac_meta_ad.X):
        atac_expr_values = pd.DataFrame(atac_meta_ad.X.toarray(), index=atac_meta_ad.obs.index, columns=atac_meta_ad.var.index)
    else:
        atac_expr_values = pd.DataFrame(atac_meta_ad.X, index=atac_meta_ad.obs.index, columns=atac_meta_ad.var.index)

    # Add the RNA and ATAC expression values for each gene
    combined_expr_values = rna_expr_values + atac_expr_values
    
    # Add the cell type information to the combined expression matrix
    combined_expr_values["celltype"] = rna_meta_ad.obs["celltype"]

    # Compute the mean expression of the combined values by cell type for each gene
    mean_combined_expr_by_celltype = combined_expr_values.groupby("celltype").mean().T  # Transpose to make genes the rows

    # For each gene, find the cell type with the highest combined RNA + ATAC expression
    top_celltype_per_gene = mean_combined_expr_by_celltype.idxmax(axis=1)

    return top_celltype_per_gene

# Initialize a DataFrame to store the results for all genes and cell types
results_df = pd.DataFrame()

# Loop through each data_id
for i, data_id in enumerate(list_datasets):
    # Import the RNA and ATAC adata objects (aggregated over metacells)
    data_name = data_id.strip("reseq")
    rna_meta_ad = sc.read_h5ad(metacell_path + f"{data_id}/{data_name}_RNA_seacells_aggre.h5ad")
    atac_meta_ad = sc.read_h5ad(metacell_path + f"{data_id}/{data_name}_ATAC_seacells_aggre.h5ad")
    
    # Import the RNA adata (not aggregated) to compute prevalent cell types
    rna_ad = sc.read_h5ad(metacell_path + f"{data_id}/{data_name}_RNA_seacells.h5ad")
    
    # Compute the most prevalent cell type for each metacell
    prevalent_celltypes = compute_prevalent_celltype_per_metacell(rna_ad, celltype_key="annotation_ML_coarse", metacell_key="SEACell")
    
    # Subset the features that are shared between RNA and ATAC (gene names)
    shared_genes = np.intersect1d(rna_meta_ad.var_names, atac_meta_ad.var_names)
    print(f"Number of shared genes: {len(shared_genes)}")

    # Subset the RNA and ATAC objects for the shared genes
    rna_meta_ad = rna_meta_ad[:, shared_genes]
    atac_meta_ad = atac_meta_ad[:, shared_genes]
    
    # Map the prevalent cell types to each metacell in the obs
    rna_meta_ad.obs["celltype"] = rna_meta_ad.obs_names.map(prevalent_celltypes)
    atac_meta_ad.obs["celltype"] = atac_meta_ad.obs_names.map(prevalent_celltypes)
    
    # Compute the top cell type based on combined RNA and ATAC values for each gene
    top_combined_celltype = compute_top_celltype_by_combined_expression(rna_meta_ad, atac_meta_ad)
    
    # Create a DataFrame to store the results for the current data_id
    temp_df = pd.DataFrame({
        'gene': shared_genes,
        f'top_combined_celltype_{data_name}': top_combined_celltype
    }).reset_index(drop=True)
    
    # Merge with the results DataFrame
    if results_df.empty:
        results_df = temp_df
    else:
        results_df = results_df.merge(temp_df, on='gene', how='outer')

# Display the final results DataFrame
print(results_df)

# %%
results_df.set_index("gene", inplace=True)
results_df

# %%
results_df.loc[list_genes]

# %%
results_df_filtered = results_df.loc[list_genes]
results_df_filtered

# %%
df_marker_celltypes = final_df.loc[list_genes]
df_marker_celltypes

# %%
df_marker_celltypes.top_celltype_1.unique()

# %%
genes_clust_1 = clusts[clusts.gene_cluster=="1"].Gene.to_list()

# %%
clusts[clusts.gene_cluster=="1"].Gene

# %%
# Filter for the row where the Gene column is 'slc4a1a'
gene_row = clusts[clusts['Gene'] == 'slc4a1a']

# Display the result
print(gene_row)

# %%
# Filter for the row where the Gene column is 'cdx1a'
gene_row = clusts[clusts['Gene'] == 'cdx1a']

# Display the result
print(gene_row)

# %%
print("slc4a1a" in genes_clust_1)
print("myf5" in genes_clust_1)
print("tbxta" in genes_clust_1)

# %%
# gene_cluster 1
genes_clust_1 = clusts[clusts.gene_cluster=="1"].Gene.to_list()

# save as a txt file
with open("genes_clust_1.txt", 'w') as output:
    for row in genes_clust_1:
        output.write(str(row) + '\n')

# %%
# gene_cluster 2
genes_clust_2 = clusts[clusts.gene_cluster=="2"].Gene.to_list()

# save as a txt file
with open("genes_clust_2.txt", 'w') as output:
    for row in genes_clust_2:
        output.write(str(row) + '\n')

# %%
# gene_cluster 3
genes_clust_3 = clusts[clusts.gene_cluster=="3"].Gene.to_list()

# save as a txt file
with open("genes_clust_3.txt", 'w') as output:
    for row in genes_clust_3:
        output.write(str(row) + '\n')

# %%
# gene_cluster 4
genes_clust_4 = clusts[clusts.gene_cluster=="4"].Gene.to_list()

# save as a txt file
with open("genes_clust_4.txt", 'w') as output:
    for row in genes_clust_4:
        output.write(str(row) + '\n')

# %%
# gene_cluster 5
genes_clust_5 = clusts[clusts.gene_cluster=="5"].Gene.to_list()

# save as a txt file
with open("genes_clust_5.txt", 'w') as output:
    for row in genes_clust_5:
        output.write(str(row) + '\n')

# %%
hbbe1

# %%
clusts[clusts.Gene=="hbbe1.1"]

# %%

# %%
markers_endo = ["fgfrl1b","col2a1a","ptprfa","emid1","nr5a2","ism2a","pawr","mmp15b","foxa3","onecut1"]
markers_meso = ["msgn1","meox1","tbx6","tbxta","fgf8a","her1"]
markers_neuro = ["pax7a","pax6a","pax6b","col18a1a","en2b","znf536","gpm6aa","gli3","chl1a"]
markers_hemato = ["lmo2","etv2","tal1","sox17"]
manual_markers = ["hbbe3","sox2","myf5","meis1a","meis3","nr2f5"]

import itertools

list_markers = list(itertools.chain(markers_endo, markers_meso, markers_neuro, markers_hemato, manual_markers))
list_markers

# %%

# %%
list_genes = [
 #'fgfrl1b',
 #'col2a1a',
 #'foxa3',
 'msgn1',
 #'meox1',
 'tbx6',
 #'tbxta',
 #'fgf8a',
 #'her1',
 'pax7a',
 #'pax6a',
 #'pax6b',
 #'en2b',
 'gli3',
 #'lmo2',
 #'sox17',
 'hbbe3',
 #'sox2',
 'myf5',
 'foxd3']

# %%
df_exp_sorted.head(30).index

# %%
list_genes = [
 #'fgfrl1b',
 #'col2a1a',
 #'foxa3',
 'msgn1',
 #'meox1',
 'tbx6',
 #'tbxta',
 #'fgf8a',
 #'her1',
 'pax7a',
 #'pax6a',
 #'pax6b',
 #'en2b',
 'gli3',
 #'lmo2',
 #'sox17',
 'hbbe3',
 #'sox2',
 'myf5',
 'foxd3']

list_dynamic_genes = ["hbbe3","hbae5","slc4a1a",
                      "hoxc8a","myo9b","sox17","cdx1a","wnt9b",
                      "myf5","msgn1","tbx6","myl1","six7"]

# %%
for marker in list_markers:
    print(df.loc[marker])

# %%
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans

# Normalize the data (z-score normalization)
scaler = StandardScaler()
df_normalized = pd.DataFrame(scaler.fit_transform(df_corr.T).T, index=df_corr.index, columns=df_corr.columns)

# Perform k-means clustering
kmeans = KMeans(n_clusters=4, random_state=0)
df_corr['Cluster'] = kmeans.fit_predict(df_normalized)

# Sort the DataFrame by cluster labels
df_sorted = df_corr.sort_values('Cluster').drop(columns='Cluster')

# %%
df_sorted

# %%
# df_diff.sort_values("Difference",ascending=False)

# %%
# df.sort_values("Difference")

# %%
# Using the differences between the first and the last timepoints to compute the "difference",
# then, use it for the k-means clustering
df['Difference'] = df_corr.iloc[:, -3] - df_corr.iloc[:, 0]

# Reshape for clustering
df_diff = df[['Difference']]

# Perform k-means clustering based on the difference
kmeans = KMeans(n_clusters=4, random_state=0)
df['Cluster'] = kmeans.fit_predict(df_diff)

# Sort the DataFrame by cluster labels
df_sorted = df.sort_values('Cluster').drop(columns=['Difference', 'Cluster'])

# Plot the clustermap
sns.clustermap(df_sorted, method='ward', metric='euclidean', cmap='viridis', 
               row_cluster=True, col_cluster=False, 
               xticklabels=False, yticklabels=False, 
               figsize=(3, 10), vmax=1, vmin=-0.1)

plt.show()

# %%
most_prevalent
prevalent_count

# %%
total_counts

# %%
'/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/data/processed_data/05_SEACells_processed/'

# %%
# check the RNA/ATAC correlation at each timepoint as the scatter plot

# define the list of datasets (data_id)
list_datasets = ['TDR126', 'TDR127', 'TDR128',
                'TDR118reseq', 'TDR125reseq', 'TDR124reseq']

# first, import all datasets (adata) and save in a dictionary
dict_meta_ad = {}

# define the directory for the data path
seacellpath = "/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/data/processed_data/05_SEACells_processed/"

for data_id in list_datasets:
    # define the sample_id (withou "reseq" in the handle)
    sample_id = data_id.replace("reseq","")
    
    # improt the single-cell adata's annotation (with adata.obs["SEACell"] annotation)
    df_seacells = pd.read_csv(seacellpath + f"{data_id}_seacells_obs_annotation_ML_coarse.csv", index_col=0)
    
    # Group by SEACell and find the most prevalent annotation for each SEACell
    most_prevalent = df_seacells.groupby('SEACell')['annotation_ML_coarse'].agg(lambda x: x.value_counts().idxmax())
    prevalent_count = df_seacells.groupby('SEACell')['annotation_ML_coarse'].agg(lambda x: x.value_counts().max())
    total_counts = df_seacells.groupby('SEACell')['annotation_ML_coarse'].count()
    prevalent_freq = prevalent_count/total_counts

    # define a dataframe
    df_prevalent = pd.DataFrame({
        'SEACell': most_prevalent.index,
        'most_prevalent_annotation': most_prevalent.values,
        'prevalent_frequency': prevalent_freq.values
    })

    df_prevalent.set_index("SEACell", inplace=True)
    df_prevalent

    # Convert the result to a dictionary
    seacell_to_annotation = df_prevalent["most_prevalent_annotation"].to_dict()
    # print(seacell_to_annotation)

    # import RNA adata (aggregated over seacells)
    rna_meta_ad = sc.read_h5ad(seacellpath + f"{data_id}/{sample_id}_RNA_seacells_aggre.h5ad")
    #import ATAC adata (aggregated over seacells)
    atac_meta_ad = sc.read_h5ad(seacellpath + f"{data_id}/{sample_id}_ATAC_seacells_aggre.h5ad")
    
    # First, we'll subset the features that are shared between RNA and ATAC (gene names)
    shared_genes = np.intersect1d(rna_meta_ad.var_names, atac_meta_ad.var_names)
    print(f"Number of shared genes: {len(shared_genes)}")

    # subset the RNA and ATAC objects for the shared genes
    rna_meta_ad = rna_meta_ad[:, shared_genes]
    atac_meta_ad = atac_meta_ad[:, shared_genes]
    
    # transfer the "most prevalent celltype" annotation to the aggregated objects
    rna_meta_ad.obs["celltype"] = rna_meta_ad.obs_names.map(seacell_to_annotation)
    atac_meta_ad.obs["celltype"] = atac_meta_ad.obs_names.map(seacell_to_annotation)
    
    # save in a dictionary
    dict_meta_ad[f"{sample_id}_rna"] = rna_meta_ad
    dict_meta_ad[f"{sample_id}_atac"] = atac_meta_ad
    

    

# %%
dict_meta_ad.keys()

# %%
# colormap
# Define the timepoints
timepoints = ['TDR126', 'TDR127', 'TDR128', 'TDR118', 'TDR125', 'TDR124']

# Load the "viridis" colormap
viridis = plt.cm.get_cmap('viridis', 256)

# Select a subset of the colormap to ensure that "30 somites" is yellow
# You can adjust the start and stop indices to shift the colors
start = 50
stop = 256
colors = viridis(np.linspace(start/256, stop/256, len(timepoints)))

# Create a dictionary to map timepoints to colors
color_dict = dict(zip(timepoints, colors))
color_dict

# %%
# A module to define the color palettes used in this paper
import matplotlib.pyplot as plt
import seaborn as sns

# a color palette for the "coarse" grained celltype annotation ("annotation_ML_coarse")
cell_type_color_dict = {
    'NMPs': '#8dd3c7',
    'PSM': '#008080',
    'differentiating_neurons': '#bebada',
    'endocrine_pancreas': '#fb8072',
    'endoderm': '#80b1d3',
    'enteric_neurons': '#fdb462',
    'epidermis': '#b3de69',
    'fast_muscle': '#df4b9b',
    'floor_plate': '#d9d9d9',
    'hatching_gland': '#bc80bd',
    'heart_myocardium': '#ccebc5',
    'hemangioblasts': '#ffed6f',
    'hematopoietic_vasculature': '#e41a1c',
    'hindbrain': '#377eb8',
    'lateral_plate_mesoderm': '#4daf4a',
    'midbrain_hindbrain_boundary': '#984ea3',
    'muscle': '#ff7f00',
    'neural': '#e6ab02',
    'neural_crest': '#a65628',
    'neural_floor_plate': '#66a61e',
    'neural_optic': '#999999',
    'neural_posterior': '#393b7f',
    'neural_telencephalon': '#fdcdac',
    'neurons': '#cbd5e8',
    'notochord': '#f4cae4',
    'optic_cup': '#c0c000',
    'pharyngeal_arches': '#fff2ae',
    'primordial_germ_cells': '#f1e2cc',
    'pronephros': '#cccccc',
    'somites': '#1b9e77',
    'spinal_cord': '#d95f02',
    'tail_bud': '#7570b3'
}


# %%
list_timepoints = ['TDR126', 'TDR127', 'TDR128', 'TDR118', 'TDR125', 'TDR124']

# for each gene, generate the time-resolved scatter plots for the RNA/ATAC correlation
for gene in ["myf5"]:
    fig, axs = plt.subplots(1, 6, figsize=(30,5))
    # loop over all timepoints
    for index, sample_id in enumerate(list_timepoints):
        # extract the rna_ad and atac_ad
        rna_ad = dict_meta_ad[f"{sample_id}_rna"]
        atac_ad = dict_meta_ad[f"{sample_id}_atac"]
        
        # compute the correlation between RNA and ATAC
        expr_rna = rna_ad[:, gene].X.toarray().flatten()
        expr_atac = atac_ad[:, gene].X.toarray().flatten()
        
        # if either exp1 or expr2 are "constant", then
        if np.all(expr_rna == expr_rna[0]) or np.all(expr_atac == expr_atac[0]):
            correlation = np.nan
        else:
            correlation, _ = pearsonr(expr_atac, expr_rna)
        
        # Get the cell type for each cell
        cell_types = rna_ad.obs["celltype"]
        
        # Map the cell type to colors
        colors = cell_types.map(cell_type_color_dict)
        
        # Plot the scatter plot for the current timepoint
        axs[index].scatter(expr_atac, expr_rna, c=colors)
        axs[index].set_title(f"{sample_id} (r={correlation:.2f})")
        axs[index].set_xlabel('ATAC expression')
        axs[index].set_ylabel('RNA expression')
        axs[index].grid(False)
        axs[index].set_xlim([-0.1, 6])
        axs[index].set_ylim([-0.1, 5])
    
    plt.suptitle(f"Scatter plots for {gene}", fontsize=16)
    plt.tight_layout(rect=[0, 0, 1, 0.95])  # Adjust layout to fit the main title

    # plt.savefig(figpath + f"scatter_atac_rna_{gene}.png")
    # plt.savefig(figpath + f"scatter_atac_rna_{gene}.pdf")
    plt.show()
        

# %%
figpath = "/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/zebrahub-multiome-analysis/figures/RNA_ATAC_corr_seacells/"

# %%
# for each gene, generate the time-resolved scatter plots for the RNA/ATAC correlation
for gene in ["myl1"]:
    fig, axs = plt.subplots(1, 6, figsize=(30,5))
    # loop over all timepoints
    for index, sample_id in enumerate(list_timepoints):
        # extract the rna_ad and atac_ad
        rna_ad = dict_meta_ad[f"{sample_id}_rna"]
        atac_ad = dict_meta_ad[f"{sample_id}_atac"]
        
        # compute the correlation between RNA and ATAC
        expr_rna = rna_ad[:, gene].X.toarray().flatten()
        expr_atac = atac_ad[:, gene].X.toarray().flatten()
        
        # if either exp1 or expr2 are "constant", then
        if np.all(expr_rna == expr_rna[0]) or np.all(expr_atac == expr_atac[0]):
            correlation = np.nan
        else:
            correlation, _ = pearsonr(expr_atac, expr_rna)
        
        # Get the cell type for each cell
        cell_types = rna_ad.obs["celltype"]
        
        # Map the cell type to colors
        colors = cell_types.map(cell_type_color_dict)
        
        # Plot the scatter plot for the current timepoint
        axs[index].scatter(expr_atac, expr_rna, color=colors)
        axs[index].set_title(f"{sample_id} (r={correlation:.2f})")
        axs[index].set_xlabel('ATAC expression')
        axs[index].set_ylabel('RNA expression')
        axs[index].grid(False)
        axs[index].set_xlim([-0.1, 5])
        axs[index].set_ylim([-0.1, 6])
    
    plt.suptitle(f"Scatter plots for {gene}", fontsize=16)
    plt.tight_layout(rect=[0, 0, 1, 0.95])  # Adjust layout to fit the main title

    plt.savefig(figpath + f"scatter_atac_rna_{gene}.png")
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.pdf")
    plt.show()

# %%
df_exp_sorted.head(100).index

# %%
list_genes_test = ['tbx5a', 'apc2', 'si:dkey-31f5.11', 'anp32b', 'hbbe2', 'gabbr1b',
       'acer2', 'vwa7', 'ecscr', 'aqp8a.2', 'si:ch211-227m13.1', 'mt-atp6',
       'pcdh2ab9', 'nid1a', 'NRXN2', 'kcnq3', 'camta1', 'prtgb', 'lingo4b',
       'dipk2b', 'celf5a', 'abcc8', 'blvrb', 'scn4ab', 'magi3b', 'clic2',
       'stx1b', 'tubb1', 'alpk3b', 'usp13', 'jak2a', 'mt-nd4', 'SRCIN1',
       'slc40a1', 'gpm6aa', 'hif1al2', 'cpox', 'ikzf1', 'pip5kl1', 'rhag',
       'magixb', 'kel', 'tnk2b', 'ptprua', 'vax2', 'slc17a6a', 'ryr1b',
       'si:dkey-25o1.7.1', 'sgcd']

# %%
# rna_ad = sc.read_h5ad("/hpc/projects/data.science/yangjoon.kim/zebrahub_multiome/data/processed_data/05_SEACells_processed/TDR118reseq_seacells_annotation_ML_coarse.h5ad")
# rna_ad

# %%
# rna_ad.obs[["SEACell","annotation_ML_coarse"]]


# %%
# for each gene, generate the time-resolved scatter plots for the RNA/ATAC correlation
for gene in list_genes_test:
    fig, axs = plt.subplots(1, 6, figsize=(30,5))
    # loop over all timepoints
    for index, sample_id in enumerate(list_timepoints):
        # extract the rna_ad and atac_ad
        rna_ad = dict_meta_ad[f"{sample_id}_rna"]
        atac_ad = dict_meta_ad[f"{sample_id}_atac"]
        
        # compute the correlation between RNA and ATAC
        expr_rna = rna_ad[:, gene].X.toarray().flatten()
        expr_atac = atac_ad[:, gene].X.toarray().flatten()
        
        # if either exp1 or expr2 are "constant", then
        if np.all(expr1 == expr1[0]) or np.all(expr2 == expr2[0]):
            correlation = np.nan
        else:
            correlation, _ = pearsonr(expr_atac, expr_rna)
        
        # Get the cell type for each cell
        cell_types = rna_ad.obs["celltype"]
        
        # Map the cell type to colors
        colors = cell_types.map(cell_type_color_dict)
        
        # Plot the scatter plot for the current timepoint
        axs[index].scatter(expr_atac, expr_rna, color=colors)
        axs[index].set_title(f"{sample_id} (r={correlation:.2f})")
        axs[index].set_xlabel('ATAC expression')
        axs[index].set_ylabel('RNA expression')
        axs[index].grid(False)
        # axs[index].set_xlim([-0.1, 5])
        # axs[index].set_ylim([-0.1, 4])
    
    plt.suptitle(f"Scatter plots for {gene}", fontsize=16)
    plt.tight_layout(rect=[0, 0, 1, 0.95])  # Adjust layout to fit the main title
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.png")
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.pdf")
    plt.show()

# %%
# list_dynamic_genes = ['hbbe3',
#  'hbae5',
#  'slc4a1a',
#  'hoxc8a',
#  'myo9b',
#  'sox17',
#  'cdx1a',
#  'wnt9b',
#  'myf5',
#  'msgn1',
#  'tbx6', 'myl1']

# %%
# for each gene, generate the time-resolved scatter plots for the RNA/ATAC correlation
for gene in list_dynamic_genes:
    fig, axs = plt.subplots(1, 6, figsize=(30,5))
    # loop over all timepoints
    for index, sample_id in enumerate(list_timepoints):
        # extract the rna_ad and atac_ad
        rna_ad = dict_meta_ad[f"{sample_id}_rna"]
        atac_ad = dict_meta_ad[f"{sample_id}_atac"]
        
        # compute the correlation between RNA and ATAC
        expr_rna = rna_ad[:, gene].X.toarray().flatten()
        expr_atac = atac_ad[:, gene].X.toarray().flatten()
        
        # if either exp1 or expr2 are "constant", then
        if np.all(expr1 == expr1[0]) or np.all(expr2 == expr2[0]):
            correlation = np.nan
        else:
            correlation, _ = pearsonr(expr_atac, expr_rna)
        
        # Get the cell type for each cell
        cell_types = rna_ad.obs["celltype"]
        
        # Map the cell type to colors
        colors = cell_types.map(cell_type_color_dict)
        
        # Plot the scatter plot for the current timepoint
        axs[index].scatter(expr_atac, expr_rna, color=colors)
        axs[index].set_title(f"{sample_id} (r={correlation:.2f})")
        axs[index].set_xlabel('ATAC expression')
        axs[index].set_ylabel('RNA expression')
        axs[index].grid(False)
        # axs[index].set_xlim([-0.1, 5])
        # axs[index].set_ylim([-0.1, 4])
    
    plt.suptitle(f"Scatter plots for {gene}", fontsize=16)
    plt.tight_layout(rect=[0, 0, 1, 0.95])  # Adjust layout to fit the main title

    plt.savefig(figpath + f"scatter_atac_rna_{gene}.png")
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.pdf")
    plt.show()

# %%
color_dict

# %%
# For each gene, generate the time-resolved scatter plots for the RNA/ATAC correlation
for gene in ["hbbe3"]:
    fig, axs = plt.subplots(1, len(list_timepoints), figsize=(30, 5))
    
    # Initialize lists to collect min and max values
    all_expr_rna = []
    all_expr_atac = []
    
    # Loop over all timepoints
    for index, sample_id in enumerate(list_timepoints):
        # Extract the rna_ad and atac_ad
        rna_ad = dict_meta_ad[f"{sample_id}_rna"]
        atac_ad = dict_meta_ad[f"{sample_id}_atac"]
        
        # Compute the correlation between RNA and ATAC
        expr_rna = rna_ad[:, gene].X.toarray().flatten()
        expr_atac = atac_ad[:, gene].X.toarray().flatten()
        
        # Debugging prints
        print(f"Sample ID: {sample_id}, Gene: {gene}")
        print(f"RNA expression: {expr_rna}")
        print(f"ATAC expression: {expr_atac}")
        
        # Collect values for global min and max calculation
        all_expr_rna.extend(expr_rna)
        all_expr_atac.extend(expr_atac)
        
        # Get the cell type for each cell
        cell_types = rna_ad.obs["celltype"]
        
        # Debugging prints
        print(f"Cell types: {cell_types}")
        
        # Map the cell type to colors
        colors = cell_types.map(cell_type_color_dict)
        
        # Debugging prints
        print(f"Colors: {colors}")
        
        # If either expr_rna or expr_atac are "constant"
        if np.all(expr_rna == expr_rna[0]) or np.all(expr_atac == expr_atac[0]):
            correlation = np.nan
        else:
            correlation, _ = pearsonr(expr_atac, expr_rna)
        
        # Plot the scatter plot for the current timepoint
        scatter = axs[index].scatter(expr_atac, expr_rna, c=colors)
        axs[index].set_title(f"{sample_id} (r={correlation:.2f})")
        axs[index].grid(False)
    
    # Calculate global min and max values for xlim and ylim
    x_min, x_max = min(all_expr_atac), max(all_expr_atac)
    y_min, y_max = min(all_expr_rna), max(all_expr_rna)
    
    # Set consistent xlim and ylim for all subplots
    for ax in axs:
        ax.set_xlim([x_min, x_max])
        ax.set_ylim([y_min, y_max])
        ax.xaxis.set_major_locator(plt.MaxNLocator(integer=True))
        ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))
        ax.set_xlabel('')
        ax.set_ylabel('')
    
    # Set global x-axis and y-axis labels
    fig.text(0.5, 0.04, 'ATAC expression', ha='center', va='center', fontsize=14)
    fig.text(0.06, 0.5, 'RNA expression', ha='center', va='center', rotation='vertical', fontsize=14)
    
    plt.suptitle(f"Scatter plots for {gene}", fontsize=16)
    plt.tight_layout(rect=[0.06, 0.04, 1, 0.95])  # Adjust layout to fit the main title

    plt.savefig(figpath + f"scatter_atac_rna_{gene}.png")
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.pdf")
    plt.show()

# %%
list_markers

# %%
# For each gene, generate the time-resolved scatter plots for the RNA/ATAC correlation
for gene in list_dynamic_genes:
    fig, axs = plt.subplots(1, len(list_timepoints), figsize=(30, 5))
    
    # Initialize lists to collect min and max values
    all_expr_rna = []
    all_expr_atac = []
    
    # Loop over all timepoints
    for index, sample_id in enumerate(list_timepoints):
        # Extract the rna_ad and atac_ad
        rna_ad = dict_meta_ad[f"{sample_id}_rna"]
        atac_ad = dict_meta_ad[f"{sample_id}_atac"]
        
        # Compute the correlation between RNA and ATAC
        expr_rna = rna_ad[:, gene].X.toarray().flatten()
        expr_atac = atac_ad[:, gene].X.toarray().flatten()
        
        # Collect values for global min and max calculation
        all_expr_rna.extend(expr_rna)
        all_expr_atac.extend(expr_atac)
        
        # Get the cell type for each cell
        cell_types = rna_ad.obs["celltype"]
        
        # Map the cell type to colors
        colors = cell_types.map(cell_type_color_dict)
        
        # If either expr_rna or expr_atac are "constant"
        if np.all(expr_rna == expr_rna[0]) or np.all(expr_atac == expr_atac[0]):
            correlation = np.nan
        else:
            correlation, _ = pearsonr(expr_atac, expr_rna)
        
        # Plot the scatter plot for the current timepoint
        axs[index].scatter(expr_atac, expr_rna, c=colors)
        axs[index].set_title(f"r={correlation:.2f}")
        axs[index].grid(False)
    
    # Calculate global min and max values for xlim and ylim
    x_min, x_max = min(all_expr_atac), max(all_expr_atac)
    y_min, y_max = min(all_expr_rna), max(all_expr_rna)
    
    # Set consistent xlim and ylim for all subplots
    for ax in axs:
        ax.set_xlim([x_min, x_max+0.5])
        ax.set_ylim([y_min, y_max+0.5])
        ax.xaxis.set_major_locator(plt.MaxNLocator(integer=True))
        ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))
        ax.set_xlabel('')
        ax.set_ylabel('')
    
    # Set global x-axis and y-axis labels
    fig.text(0.5, 0.04, 'ATAC expression', ha='center', va='center', fontsize=16)
    fig.text(0.06, 0.5, 'RNA expression', ha='center', va='center', rotation='vertical', fontsize=16)
    
    plt.suptitle(f"Scatter plots for {gene}", fontsize=16)
    plt.tight_layout(rect=[0.06, 0.04, 1, 0.95])  # Adjust layout to fit the main title
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.png")
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.pdf")
    plt.show()

# %%
# For each gene, generate the time-resolved scatter plots for the RNA/ATAC correlation
for gene in list_genes_test:
    fig, axs = plt.subplots(1, len(list_timepoints), figsize=(30, 5))
    
    # Initialize lists to collect min and max values
    all_expr_rna = []
    all_expr_atac = []
    
    # Loop over all timepoints
    for index, sample_id in enumerate(list_timepoints):
        # Extract the rna_ad and atac_ad
        rna_ad = dict_meta_ad[f"{sample_id}_rna"]
        atac_ad = dict_meta_ad[f"{sample_id}_atac"]
        
        # Compute the correlation between RNA and ATAC
        expr_rna = rna_ad[:, gene].X.toarray().flatten()
        expr_atac = atac_ad[:, gene].X.toarray().flatten()
        
        # Collect values for global min and max calculation
        all_expr_rna.extend(expr_rna)
        all_expr_atac.extend(expr_atac)
        
        # Get the cell type for each cell
        cell_types = rna_ad.obs["celltype"]
        
        # Map the cell type to colors
        colors = cell_types.map(cell_type_color_dict)
        
        # If either expr_rna or expr_atac are "constant"
        if np.all(expr_rna == expr_rna[0]) or np.all(expr_atac == expr_atac[0]):
            correlation = np.nan
        else:
            correlation, _ = pearsonr(expr_atac, expr_rna)
        
        # Plot the scatter plot for the current timepoint
        axs[index].scatter(expr_atac, expr_rna, c=colors)
        axs[index].set_title(f"r={correlation:.2f}")
        axs[index].tick_params(axis='x', labelsize=12)
        axs[index].tick_params(axis='y', labelsize=12)
        axs[index].grid(False)
    
    # Calculate global min and max values for xlim and ylim
    x_min, x_max = min(all_expr_atac), max(all_expr_atac)
    y_min, y_max = min(all_expr_rna), max(all_expr_rna)
    
    # Set consistent xlim and ylim for all subplots
    for ax in axs:
        ax.set_xlim([x_min, x_max+0.5])
        ax.set_ylim([y_min, y_max+0.5])
        ax.xaxis.set_major_locator(plt.MaxNLocator(integer=True))
        ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))
        ax.set_xlabel('')
        ax.set_ylabel('')
    
    # Set global x-axis and y-axis labels
    fig.text(0.5, 0.04, 'ATAC expression', ha='center', va='center', fontsize=16)
    fig.text(0.06, 0.5, 'RNA expression', ha='center', va='center', rotation='vertical', fontsize=16)
    
    plt.suptitle(f"Scatter plots for {gene}", fontsize=16)
    plt.tight_layout(rect=[0.06, 0.04, 1, 0.95])  # Adjust layout to fit the main title
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.png")
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.pdf")
    plt.show()

# %%
# For each gene, generate the time-resolved scatter plots for the RNA/ATAC correlation

# define the list of genes (increasing correlation)
list_genes_manual = ["slc4a1a","sgcd","vax2","ptprua","rhag",
                     "tbx5a","gabbr1b","vwa7","celf5a","ikzf1",
                     "stx1b","scn4ab","blvrb"]

for gene in list_genes_manual:
    fig, axs = plt.subplots(1, len(list_timepoints), figsize=(30, 5))
    
    # Initialize lists to collect min and max values
    all_expr_rna = []
    all_expr_atac = []
    
    # Loop over all timepoints
    for index, sample_id in enumerate(list_timepoints):
        # Extract the rna_ad and atac_ad
        rna_ad = dict_meta_ad[f"{sample_id}_rna"]
        atac_ad = dict_meta_ad[f"{sample_id}_atac"]
        
        # Compute the correlation between RNA and ATAC
        expr_rna = rna_ad[:, gene].X.toarray().flatten()
        expr_atac = atac_ad[:, gene].X.toarray().flatten()
        
        # Collect values for global min and max calculation
        all_expr_rna.extend(expr_rna)
        all_expr_atac.extend(expr_atac)
        
        # Get the cell type for each cell
        cell_types = rna_ad.obs["celltype"]
        
        # Map the cell type to colors
        colors = cell_types.map(cell_type_color_dict)
        
        # If either expr_rna or expr_atac are "constant"
        if np.all(expr_rna == expr_rna[0]) or np.all(expr_atac == expr_atac[0]):
            correlation = np.nan
        else:
            correlation, _ = pearsonr(expr_atac, expr_rna)
        
        # Plot the scatter plot for the current timepoint
        axs[index].scatter(expr_atac, expr_rna, c=colors)
        axs[index].set_title(f"r={correlation:.2f}")
        axs[index].tick_params(axis='x', labelsize=12)
        axs[index].tick_params(axis='y', labelsize=12)
        axs[index].grid(False)
    
    # Calculate global min and max values for xlim and ylim
    x_min, x_max = min(all_expr_atac)-0.5, max(all_expr_atac)
    y_min, y_max = min(all_expr_rna)-0.5, max(all_expr_rna)
    
    # Set consistent xlim and ylim for all subplots
    for ax in axs:
        ax.set_xlim([x_min, x_max+0.5])
        ax.set_ylim([y_min, y_max+0.5])
        ax.xaxis.set_major_locator(plt.MaxNLocator(integer=True))
        ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))
        ax.set_xlabel('')
        ax.set_ylabel('')
    
    # Set global x-axis and y-axis labels
    fig.text(0.5, 0.04, 'ATAC expression', ha='center', va='center', fontsize=16)
    fig.text(0.06, 0.5, 'RNA expression', ha='center', va='center', rotation='vertical', fontsize=16)
    
    plt.suptitle(f"Scatter plots for {gene}", fontsize=16)
    plt.tight_layout(rect=[0.06, 0.04, 1, 0.95])  # Adjust layout to fit the main title
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.png")
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.pdf")
    plt.show()

# %%
# For each gene, generate the time-resolved scatter plots for the RNA/ATAC correlation

# define the list of genes (increasing correlation)
list_genes_manual_down = ["cdx1a","hoxc8a","myo9b","sox17",
                          "myf5","msgn1","tbx6"]

for gene in list_genes_manual_down:
    fig, axs = plt.subplots(1, len(list_timepoints), figsize=(30, 5))
    
    # Initialize lists to collect min and max values
    all_expr_rna = []
    all_expr_atac = []
    
    # Loop over all timepoints
    for index, sample_id in enumerate(list_timepoints):
        # Extract the rna_ad and atac_ad
        rna_ad = dict_meta_ad[f"{sample_id}_rna"]
        atac_ad = dict_meta_ad[f"{sample_id}_atac"]
        
        # Compute the correlation between RNA and ATAC
        expr_rna = rna_ad[:, gene].X.toarray().flatten()
        expr_atac = atac_ad[:, gene].X.toarray().flatten()
        
        # Collect values for global min and max calculation
        all_expr_rna.extend(expr_rna)
        all_expr_atac.extend(expr_atac)
        
        # Get the cell type for each cell
        cell_types = rna_ad.obs["celltype"]
        
        # Map the cell type to colors
        colors = cell_types.map(cell_type_color_dict)
        
        # If either expr_rna or expr_atac are "constant"
        if np.all(expr_rna == expr_rna[0]) or np.all(expr_atac == expr_atac[0]):
            correlation = np.nan
        else:
            correlation, _ = pearsonr(expr_atac, expr_rna)
        
        # Plot the scatter plot for the current timepoint
        axs[index].scatter(expr_atac, expr_rna, c=colors)
        axs[index].set_title(f"r={correlation:.2f}")
        axs[index].tick_params(axis='x', labelsize=12)
        axs[index].tick_params(axis='y', labelsize=12)
        axs[index].grid(False)
    
    # Calculate global min and max values for xlim and ylim
    x_min, x_max = min(all_expr_atac)-0.5, max(all_expr_atac)
    y_min, y_max = min(all_expr_rna)-0.5, max(all_expr_rna)
    
    # Set consistent xlim and ylim for all subplots
    for ax in axs:
        ax.set_xlim([x_min, x_max+0.5])
        ax.set_ylim([y_min, y_max+0.5])
        ax.xaxis.set_major_locator(plt.MaxNLocator(integer=True))
        ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))
        ax.set_xlabel('')
        ax.set_ylabel('')
    
    # Set global x-axis and y-axis labels
    fig.text(0.5, 0.04, 'ATAC expression', ha='center', va='center', fontsize=16)
    fig.text(0.06, 0.5, 'RNA expression', ha='center', va='center', rotation='vertical', fontsize=16)
    
    plt.suptitle(f"Scatter plots for {gene}", fontsize=16)
    plt.tight_layout(rect=[0.06, 0.04, 1, 0.95])  # Adjust layout to fit the main title
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.png")
    plt.savefig(figpath + f"scatter_atac_rna_{gene}.pdf")
    plt.show()
